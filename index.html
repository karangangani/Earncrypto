<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>AETHER — Earn & Airdrop (Stable v6)</title>

<!-- Telegram WebApp -->
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<!-- Firebase compat -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

<!-- TON connect UI -->
<script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.css"/>

<!-- Ad SDK (kept) -->
<script src='//libtl.com/sdk.js' data-zone='10192178' data-sdk='show_10192178'></script>

<style>
:root{ --bg:linear-gradient(135deg,#0c0c0c,#1a1a2e); --card:#0f0f23; --accent:#00d38a; --text:#fff; --muted:#a0a8b0; --border:rgba(0,211,138,0.3); --glow:0 0 20px rgba(0,211,138,0.5); }
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:Segoe UI,Tahoma,Geneva,Verdana,sans-serif;background:var(--bg);color:var(--muted);min-height:100vh;padding:14px;overflow-x:hidden}
.wrap{max-width:720px;margin:12px auto}
.header{display:flex;gap:12px;align-items:center;padding:14px;border-radius:16px;background:linear-gradient(135deg, rgba(0,211,138,0.06), rgba(0,211,138,0.02));border:1px solid var(--border);box-shadow:var(--glow)}
.logo{width:64px;height:64px;border-radius:16px;background:linear-gradient(135deg,#1a1a2e,#16213e);display:flex;align-items:center;justify-content:center;color:var(--text);font-weight:900;position:relative;box-shadow:var(--glow)}
.logo::after{content:'Ae';font-size:24px;font-weight:900;color:var(--accent);text-shadow:var(--glow)}
.user-dp{width:32px;height:32px;border-radius:50%;margin-left:8px;border:2px solid var(--accent)}
h1{color:var(--text);font-size:20px;margin-bottom:2px;font-weight:700}
.sub{color:var(--muted);font-size:13px}
.card{background:var(--card);padding:18px;border-radius:16px;margin-top:12px;border:1px solid rgba(255,255,255,0.05);box-shadow:0 4px 20px rgba(0,0,0,0.3)}
.stats{display:flex;gap:10px}
.stat{flex:1;padding:14px;background:rgba(0,211,138,0.06);border-radius:12px;text-align:center;transition:all 0.3s}
.v{font-weight:900;color:var(--text);font-size:20px}
.l{font-size:11px;color:var(--muted)}
.tabs{display:flex;gap:8px;margin-top:12px}
.tab{flex:1;padding:12px;border-radius:12px;text-align:center;background:transparent;border:1px solid rgba(255,255,255,0.05);cursor:pointer;color:var(--muted);transition:all 0.3s;font-weight:600}
.tab.active{background:rgba(0,211,138,0.2);color:var(--text);border-color:var(--accent);box-shadow:var(--glow)}
.section{display:none;padding-top:12px}
.section.active{display:block;animation:fadeIn 0.5s}
@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
.btn{width:100%;padding:14px;border-radius:12px;border:none;background:linear-gradient(135deg,var(--accent),#00a877);color:#001;font-weight:800;cursor:pointer;margin-top:8px;transition:all 0.3s;box-shadow:0 4px 10px rgba(0,211,138,0.3)}
.btn.secondary{background:linear-gradient(135deg,#333,#555);color:#fff}
.btn:disabled{opacity:.6;cursor:not-allowed;transform:none}
.small{font-size:13px;color:var(--muted);margin-top:8px;text-align:center}
.ref-box{display:flex;flex-direction:column;gap:8px;padding:12px;border-radius:12px;background:rgba(0,211,138,0.04);border:1px solid var(--border)}
.levels{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;margin-top:12px}
.level{padding:12px;border-radius:12px;background:rgba(255,255,255,0.02);border:1px solid var(--border);transition:all 0.3s}
.claimBtn{background:linear-gradient(135deg,var(--accent),#00a877);color:#001;padding:10px;border-radius:8px;border:none;cursor:pointer;font-weight:700;width:100%;margin-top:10px;transition:all 0.3s}
.claimBtn:disabled{background:#333;color:#666;cursor:not-allowed}
.ref-list{list-style:none;padding:0}
.ref-item{padding:10px;background:rgba(255,255,255,0.02);border-radius:8px;margin-bottom:8px}
.footer{margin-top:20px;text-align:center;color:var(--muted);font-size:12px;padding:10px;background:rgba(0,0,0,0.2);border-radius:12px}
.modal { position: fixed; inset: 0; display:none; align-items:center; justify-content:center; z-index:99999; background: rgba(0,0,0,0.6); }
.modal .card { max-width:520px; width:92%; padding:18px; border-radius:12px; background:var(--card); border:1px solid var(--border); color:var(--muted) }
#warn{color:#ffcc66;text-align:center;margin-top:8px}

/* --- X button styling --- */
.x-follow { display:flex; gap:8px; align-items:center; justify-content:center; padding:10px 12px; border-radius:10px; font-weight:800; cursor:pointer; border:none; }
.x-follow svg { width:18px; height:18px; display:block; }
.x-follow.primary { background: linear-gradient(135deg,#1DA1F2,#00a4ff); color:#001; box-shadow:0 6px 18px rgba(0,164,255,0.12); }
.x-follow.primary:active { transform: translateY(1px); }

</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div class="logo"></div>
    <img id="user-dp" class="user-dp" src="" alt="User DP" style="display:none">
    <div>
      <h1>AETHER — Earn & Airdrop</h1>
      <div id="userLine" class="sub">Loading...</div>
    </div>
  </div>

  <div class="card">
    <div class="stats">
      <div class="stat"><div class="v" id="points">0</div><div class="l">Ae</div></div>
      <div class="stat"><div class="v" id="refs">0</div><div class="l">Referrals</div></div>
      <div class="stat"><div class="v" id="level">0</div><div class="l">Level</div></div>
    </div>

    <div class="tabs">
      <div class="tab active" onclick="openTab('home', event)">Home</div>
      <div class="tab" onclick="openTab('tasks', event)">Earn</div>
      <div class="tab" onclick="openTab('referral', event)">Invite</div>
      <div class="tab" onclick="openTab('airdrop', event)">Airdrop</div>
    </div>

    <!-- HOME -->
    <div id="home" class="section active">
      <div class="ref-box">
        <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
          <div style="flex:1;min-width:180px">
            <h3 style="color:var(--accent);margin:0 0 6px 0;font-size:14px">⭐ Official Channel</h3>
            <button id="openChannel" class="btn secondary" style="width:100%;padding:10px;font-size:14px">Join @Aetherofficialchannel</button>
          </div>

          <div style="width:180px;min-width:140px">
            <h3 style="color:var(--accent);margin:0 0 6px 0;font-size:14px">Follow on X</h3>
            <button id="followXBtn" class="x-follow primary" title="Follow us on X (Twitter)">
              <!-- X icon -->
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M23 3c-.8.35-1.7.58-2.6.69a4.48 4.48 0 0 0 1.96-2.48c-.86.51-1.8.87-2.8 1.07A4.48 4.48 0 0 0 16.5 2c-2.5 0-4.5 2.05-4.5 4.58 0 .36.04.71.12 1.05C8.1 7.55 4.3 5.7 1.7 2.48c-.4.68-.6 1.47-.6 2.32 0 1.6.82 3.02 2.06 3.85-.76-.03-1.47-.24-2.09-.57v.06c0 2.25 1.6 4.13 3.73 4.55-.39.11-.8.16-1.22.16-.3 0-.6-.03-.88-.08.6 1.94 2.35 3.35 4.42 3.39A9.04 9.04 0 0 1 1 19.54a12.8 12.8 0 0 0 6.92 2.03c8.3 0 12.85-6.8 12.85-12.7v-.58A8.94 8.94 0 0 0 23 3z"/></svg>
              <span style="font-size:14px">Follow @Aetherofficia97</span>
            </button>
          </div>
        </div>

    <!-- EARN -->
    <div id="tasks" class="section">
      <button id="watchAd" class="btn">Watch Ad (+<span id="adReward">100</span> Ae)</button>
      <p class="small" style="margin-top:8px">Level: <span id="levelDisplay">0</span> • Ads Watched (total): <span id="totalAds">0</span></p>
      <div id="warn"></div>

      <div class="small" style="margin-top:20px;font-weight:600;color:var(--accent)">Level Rewards</div>
      <div id="levelsList" class="levels"></div>
      <div style="text-align:center;margin-top:16px">
        <button id="showAllLevels" class="btn secondary">Load More Levels</button>
      </div>
    </div>

    <!-- INVITE -->
    <div id="referral" class="section">
      <div style="text-align:center;padding:20px">
        <h3 style="color:var(--accent);font-size:20px">Invite Friends & Earn</h3>
        <p style="margin-bottom:20px">Each referral = +5000 Ae for both!</p>
        <div class="ref-box">
          <div id="myRef">Generating...</div>
          <button id="copyRef" class="btn">COPY LINK</button>
        </div>
        <h3 style="color:var(--accent);font-size:20px;margin-top:20px">Your Referrals</h3>
        <ul id="refList" class="ref-list"></ul>
      </div>
    </div>

    <!-- AIRDROP -->
    <div id="airdrop" class="section">
      <div id="airdrop-locked" style="display:none;text-align:center;padding:20px;color:#ff5555">
        <h3>Airdrop Locked</h3>
        <p>Invite 3 friends to unlock!</p>
      </div>
      <div id="airdrop-content" style="display:none;text-align:center;padding:20px">
        <h3 style="color:var(--accent);font-size:22px">Airdrop Ready</h3>
        <p>Connect your TON wallet to claim.</p>
        <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
          <button id="connectTon" class="btn">Connect TON Wallet</button>
          <button id="disconnectTon" class="btn secondary" style="display:none">Disconnect Wallet</button>
          <div id="tonBtnRoot"></div>
        </div>
        <p class="small" id="walletStatus" style="margin-top:16px">Not Connected</p>
      </div>
    </div>

  </div>

  <div class="footer">© AETHER •  Project 2026</div>
</div>

<script>
/* ================== CONFIG ================== */
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyBRMiyuGkjDFfZE9tqgzGVWJalw_6Cypz4",
  authDomain: "earncryptomp.firebaseapp.com",
  projectId: "earncryptomp",
  storageBucket: "earncryptomp.firebasestorage.app",
  messagingSenderId: "405204250643",
  appId: "1:405204250643:web:8841299bceb46f6752cfe6"
};

const STATE_KEY = 'aether_state_v6';
const PENDING_KEY = 'aether_pending_v6';
const ADS_WINDOW_MS = 12 * 60 * 60 * 1000; // 12h
const ADS_WINDOW_LIMIT = 50;  // changed to 50
const DAILY_AD_LIMIT = 50;    // changed to 50
const FLUSH_THRESHOLD_AE = 3000;
const FLUSH_INTERVAL_MS = 2 * 60 * 1000;
const TON_MANIFEST = 'https://karangangani.github.io/Earncrypto/tonconnect-manifest.json';

firebase.initializeApp(FIREBASE_CONFIG);
const db = firebase.firestore();
const auth = firebase.auth();

const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : { ready:()=>{}, initDataUnsafe:{} };
try { tg.ready(); tg.expand && tg.expand(); } catch(e){}

const tgUser = tg.initDataUnsafe && tg.initDataUnsafe.user ? tg.initDataUnsafe.user : {};
let userDocId = null;

let current = {
  username: '',
  ae: 0,
  refs: [],
  referredBy: '',
  level: 0,
  adsToday: 0,
  totalAds: 0,
  claimedLevels: [],
  tonWallet: '',
  lastAdTime: 0,
  lastResetDate: new Date().toDateString(),
  multiplierAds: 1,
  multiplierAe: 1,
  giftChosen: false,
  lastSaveTime: Date.now(),
  adsWindowStart: Date.now(),
  adsWindowCount: 0
};

window.__aether_pending = window.__aether_pending || { aeDelta:0, adsDelta:0, refs:[], claimed:[], lastFlush:0 };

/* ---------------- Local storage helpers ---------------- */
function readLocal(){
  try{
    return {
      state: JSON.parse(localStorage.getItem(STATE_KEY) || 'null') || {},
      pending: JSON.parse(localStorage.getItem(PENDING_KEY) || 'null') || { aeDelta:0, adsDelta:0, refs:[], claimed:[], lastFlush:0 }
    };
  }catch(e){ return { state:{}, pending:{ aeDelta:0, adsDelta:0, refs:[], claimed:[], lastFlush:0 } }; }
}
function writeLocal(stateObj, pendingObj){
  try{
    if(stateObj) localStorage.setItem(STATE_KEY, JSON.stringify(stateObj));
    if(pendingObj) localStorage.setItem(PENDING_KEY, JSON.stringify(pendingObj));
  }catch(e){ console.warn('local write failed', e); }
}

/* init from local */
(function initLocal(){
  const { state, pending } = readLocal();
  if (state && Object.keys(state).length) Object.assign(current, state);
  window.__aether_pending = pending || window.__aether_pending;
})();

/* ---------------- Pending queue helpers ---------------- */
function enqueuePending(aeDelta=0, adsDelta=0, addRef=null, addClaim=null){
  window.__aether_pending = window.__aether_pending || { aeDelta:0, adsDelta:0, refs:[], claimed:[], lastFlush:0 };
  window.__aether_pending.aeDelta += Number(aeDelta||0);
  window.__aether_pending.adsDelta += Number(adsDelta||0);
  if(addRef) window.__aether_pending.refs.push(addRef);
  if(addClaim) window.__aether_pending.claimed.push(addClaim);
  writeLocal(current, window.__aether_pending);
}
  /* ---------------- Flush pending to Firestore ---------------- */
async function flushPending(force=false){
  try{
    window.__aether_pending = window.__aether_pending || { aeDelta:0, adsDelta:0, refs:[], claimed:[], lastFlush:0 };
    const p = window.__aether_pending;
    const now = Date.now();
    const shouldFlush = force || Math.abs(p.aeDelta || 0) >= FLUSH_THRESHOLD_AE || (now - (p.lastFlush || 0)) > (24*60*60*1000);
    if (!shouldFlush) return;
    const updates = {};
    if (p.aeDelta) updates.ae = firebase.firestore.FieldValue.increment(p.aeDelta);
    if (p.adsDelta) { updates.totalAds = firebase.firestore.FieldValue.increment(p.adsDelta); updates.adsToday = firebase.firestore.FieldValue.increment(p.adsDelta); }
    if (p.refs && p.refs.length) updates.refs = firebase.firestore.FieldValue.arrayUnion(...p.refs);
    if (p.claimed && p.claimed.length) updates.claimedLevels = firebase.firestore.FieldValue.arrayUnion(...p.claimed);
    updates.lastSaveTime = now;
    await db.collection('users').doc(userDocId).update(updates);
    window.__aether_pending = { aeDelta:0, adsDelta:0, refs:[], claimed:[], lastFlush: now };
    writeLocal(current, window.__aether_pending);
    const fresh = await db.collection('users').doc(userDocId).get();
    if (fresh.exists) { Object.assign(current, fresh.data()); if (window.__aether_pending && window.__aether_pending.aeDelta) current.ae += window.__aether_pending.aeDelta; writeLocal(current, window.__aether_pending); updateUI(); }
  }catch(e){ console.warn('flush pending error', e); throw e; }
}

/* periodic flush & online hooks */
setInterval(()=>{ flushPending(false).catch(()=>{}); }, FLUSH_INTERVAL_MS);
window.addEventListener('online', ()=>flushPending(true).catch(()=>{}));
document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState==='hidden') flushPending(true).catch(()=>{}); });
window.addEventListener('beforeunload', ()=>{ try{ writeLocal(current, window.__aether_pending);}catch(e){} });

/* ================== AD HELPER (robust) ================== */
function showAdNormalized(timeoutMs = 30000){
  return new Promise((resolve) => {
    const timer = setTimeout(()=>{ resolve({ completed: false, reason:'timeout' }); }, timeoutMs);
    try{
      if (window.show_10192178 && typeof window.show_10192178 === 'function'){
        const maybe = window.show_10192178('');
        if (maybe && typeof maybe.then === 'function'){
          maybe.then(res => { clearTimeout(timer); if(res && typeof res === 'object' && ('completed' in res)) resolve({completed: !!res.completed}); else resolve({completed:true}); }).catch(err=>{ clearTimeout(timer); resolve({completed:false, reason: err && err.message}); });
          return;
        }
      }
    }catch(e){}
    try{
      if (window.libtl && typeof window.libtl.show === 'function'){
        window.libtl.show({ zone:'10192178', onComplete: ()=>{ clearTimeout(timer); resolve({completed:true}); }, onClose:(watched)=>{ clearTimeout(timer); resolve({completed: !!watched}); }, onError: ()=>{ clearTimeout(timer); resolve({completed:false}); } });
        return;
      }
    }catch(e){}
    const handler = (ev) => { clearTimeout(timer); try{ const ok = !!(ev.detail && (ev.detail.completed || ev.detail.success)); resolve({completed: ok}); } catch(e){ resolve({completed:false}); } window.removeEventListener('libtl_ad_result', handler); };
    window.addEventListener('libtl_ad_result', handler);
    try{ if (window.show_10192178 && typeof window.show_10192178 === 'function') window.show_10192178(''); }catch(e){}
  });
}

/* fallback short modal (if SDK down) */
function showFallbackAdModal(seconds = 20){
  return new Promise((resolve) => {
    let modal = document.getElementById('fallback-ad-modal');
    if (!modal){
      modal = document.createElement('div'); modal.id='fallback-ad-modal';
      Object.assign(modal.style,{position:'fixed',left:0,right:0,top:0,bottom:0,display:'flex',alignItems:'center',justifyContent:'center',background:'rgba(0,0,0,.6)',zIndex:99999});
      modal.innerHTML = `<div style="width:90%;max-width:420px;background:#0f1724;padding:18px;border-radius:12px;color:#fff;text-align:center;border:1px solid rgba(0,211,138,0.15)">
        <h3 style="color:#00d38a">Short flow for reward</h3>
        <p style="color:#d0d6db">Ad provider temporarily unavailable. Wait <span id="fallback-count">${seconds}</span>s to get the reward, or Cancel.</p>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
          <button id="fallback-cancel" style="padding:10px 14px;border-radius:8px;border:none;background:#333;color:#fff;cursor:pointer">Cancel</button>
        </div></div>`;
      document.body.appendChild(modal);
    }
    modal.style.display='flex';
    const countEl = modal.querySelector('#fallback-count'); const cancel = modal.querySelector('#fallback-cancel');
    let rem = seconds; countEl.innerText = rem;
    const iv = setInterval(()=>{ rem--; countEl.innerText = rem; if(rem<=0){ clearInterval(iv); modal.style.display='none'; resolve({completed:true}); } },1000);
    cancel.onclick = ()=>{ clearInterval(iv); modal.style.display='none'; resolve({completed:false}); };
  });
}

/* ================== UI helpers (ensure defined before init) ================== */
function updateAdReward(){ document.getElementById('adReward').innerText = 100 * (current.multiplierAds || 1); }
function updateUI(){
  document.getElementById('points').innerText = Math.floor(current.ae || 0);
  document.getElementById('refs').innerText = (current.refs || []).length;
  document.getElementById('level').innerText = current.level || 0;
  document.getElementById('levelDisplay').innerText = current.level || 0;
  document.getElementById('totalAds').innerText = current.totalAds || 0;
  updateAdReward();
  updateWalletButtons();
}
function openTab(tabId, ev){
  document.querySelectorAll('.section').forEach(s=>s.classList.remove('active'));
  document.getElementById(tabId).classList.add('active');
  document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
  if (ev && ev.currentTarget) ev.currentTarget.classList.add('active');
  if (tabId === 'referral'){ loadRefList(); /* leaderboard removed to save reads */ }
  if (tabId === 'airdrop') toggleAirdropSection();
}

/* ---------------- Level logic ---------------- */
function computeLevel(){
  const refsCount = (current.refs || []).length;
  const adsCount = current.totalAds || 0;
  current.level = Math.min(refsCount, adsCount);
  if (!Number.isFinite(current.level) || current.level < 0) current.level = 0;
}

/* ----------------- refs (DEFINE BEFORE initApp) ----------------- */
function loadRefList(){
  const list = document.getElementById('refList');
  if(!list) return;
  list.innerHTML='';
  (current.refs||[]).forEach(r=>{
    const li = document.createElement('li');
    li.className='ref-item';
    li.innerText = `User ID: ${r}`;
    list.appendChild(li);
  });
}

/* ----------------- levels & claim (keep before init) ----------------- */
let levelsRendered = 0;
function renderLevelsChunk(max){
  const container = document.getElementById('levelsList');
  const start = levelsRendered + 1;
  const end = levelsRendered + max;
  for (let i=start;i<=end;i++){
    const refsNeeded = i; const adsNeeded = i; const reward = 500 * i;
    const el = document.createElement('div'); el.className='level';
    el.innerHTML = `<div style="font-weight:800;color:var(--accent);font-size:16px">Level ${i}</div>
      <div class="small" style="margin-top:8px">Requires: ${refsNeeded} referral${refsNeeded>1?'s':''} & ${adsNeeded} ad${adsNeeded>1?'s':''}</div>
      <div class="small" style="margin-top:8px">Reward: ${reward} Ae</div>
      <div style="margin-top:10px"><button id="claim_${i}" class="claimBtn" disabled>Claim</button></div>`;
    container.appendChild(el);
    document.getElementById(`claim_${i}`).addEventListener('click', async ()=>{ await claimLevel(i, refsNeeded, adsNeeded, reward); });
  }
  levelsRendered = end; updateLevelProgressUI();
}
function updateLevelProgressUI(){
  const refsCount = (current.refs||[]).length; const adsDone = current.totalAds || 0;
  for (let i=1;i<=levelsRendered;i++){
    const btn = document.getElementById(`claim_${i}`); if(!btn) continue;
    const claimed = (current.claimedLevels || []).includes(i);
    const canClaim = !claimed && refsCount >= i && adsDone >= i;
    btn.disabled = !canClaim; btn.innerText = claimed ? 'Claimed ✓' : 'Claim';
  }
}
async function claimLevel(levelNo, refsNeeded, adsNeeded, reward){
  const refsCount = (current.refs||[]).length; const adsDone = current.totalAds || 0;
  if (refsCount < refsNeeded || adsDone < adsNeeded) return tg.showAlert && tg.showAlert('Requirements not met');
  if ((current.claimedLevels||[]).includes(levelNo)) return tg.showAlert && tg.showAlert('Already claimed');
  current.ae = (current.ae||0) + reward; current.claimedLevels = current.claimedLevels || []; current.claimedLevels.push(levelNo);
  enqueuePending(reward, 0, null, levelNo); writeLocal(current, window.__aether_pending);
  computeLevel(); updateUI(); updateLevelProgressUI();
  if (Math.abs(window.__aether_pending.aeDelta||0) >= FLUSH_THRESHOLD_AE) await flushPending(true);
  if (tg.showAlert) tg.showAlert(`Level ${levelNo} claimed! +${reward} Ae!`);
}

/* ----------------- init app ----------------- */
const startParam = tg.initDataUnsafe && tg.initDataUnsafe.start_param ? tg.initDataUnsafe.start_param : '';
let tonUI = null;

async function initApp(){
  try{
    await auth.signInAnonymously();
    const tgId = tg.initDataUnsafe && tg.initDataUnsafe.user && tg.initDataUnsafe.user.id ? tg.initDataUnsafe.user.id.toString() : 'guest_' + Date.now();
    userDocId = tgId;
    window.__aether_pending = readLocal().pending || window.__aether_pending;
    const docRef = db.collection('users').doc(userDocId);
    const doc = await docRef.get();
    const username = (tg.initDataUnsafe && tg.initDataUnsafe.user && (tg.initDataUnsafe.user.username || tg.initDataUnsafe.user.first_name)) || 'User';
    if (!doc.exists){
      current.username = username;
      try{ await docRef.set(current); } catch(e){ console.warn('create failed', e); }
    } else {
      Object.assign(current, doc.data());
    }

    try{
      if (window.__aether_pending && (window.__aether_pending.aeDelta || window.__aether_pending.adsDelta || (window.__aether_pending.refs && window.__aether_pending.refs.length))) {
        await flushPending(true);
      } else {
        const fresh = await docRef.get();
        if (fresh.exists) Object.assign(current, fresh.data());
      }
    }catch(e){ console.warn('initial flush failed', e); }

    computeLevel();
    if (tg.initDataUnsafe && tg.initDataUnsafe.user && tg.initDataUnsafe.user.photo_url){ const el=document.getElementById('user-dp'); el.src=tg.initDataUnsafe.user.photo_url; el.style.display='block'; }
    document.getElementById('userLine').innerText = `${current.username || username} • ID: ${userDocId}`;

    // realtime update (merge server and reapply pending visually)
    docRef.onSnapshot(snap => {
      if (!snap.exists) return;
      const server = snap.data();
      Object.assign(current, server);
      if (window.__aether_pending && window.__aether_pending.aeDelta) current.ae = (current.ae || 0) + (window.__aether_pending.aeDelta || 0);
      if (window.__aether_pending && window.__aether_pending.adsDelta) current.totalAds = (current.totalAds || 0) + (window.__aether_pending.adsDelta || 0);
      computeLevel(); updateUI(); updateLevelProgressUI(); updateAdReward(); updateWalletButtons(); toggleAirdropSection(); checkLevel10Gift();
    });

    // UI hooks
    document.getElementById('openChannel').onclick = ()=>{ if (tg.openTelegramLink) tg.openTelegramLink('https://t.me/Aetherofficialchannel'); else window.open('https://t.me/Aetherofficialchannel','_blank'); };
    document.getElementById('copyRef').onclick = copyRefHandler;
    document.getElementById('showAllLevels').onclick = ()=>renderLevelsChunk(50);
    document.getElementById('watchAd').onclick = watchAdHandler;

    const refLink = `https://t.me/AetherMineXBot?start=ref_${userDocId}`;
    document.getElementById('myRef').innerText = refLink;
  // TON connect
    tonUI = new TON_CONNECT_UI.TonConnectUI({ manifestUrl: TON_MANIFEST, buttonRootId: 'tonBtnRoot' });
    tonUI.onStatusChange(async (wallet) => {
      if (wallet && wallet.account && wallet.account.address) {
        await trySaveTonWallet(wallet.account.address);
      } else {
        try{ await docRef.update({ tonWallet: '' }); } catch(e){}
        current.tonWallet = '';
        updateUI(); updateWalletButtons();
      }
    });
    document.getElementById('connectTon').onclick = ()=>tonUI.connectWallet();
    document.getElementById('disconnectTon').onclick = async ()=>{ try{ await tonUI.disconnect(); }catch(e){} try{ await docRef.update({ tonWallet: '' }); }catch(e){} current.tonWallet=''; updateUI(); updateWalletButtons(); if (tg.showAlert) tg.showAlert('Wallet disconnected!'); };

    if (startParam && startParam.startsWith('ref_')) await handleReferralParam(startParam);

    renderLevelsChunk(20);
    await resetDailyAdsIfNeeded();
    updateUI(); updateAdReward();
    loadRefList();

    // recover stuck button when user returns from ad (focus)
    window.addEventListener('focus', () => {
      const btn = document.getElementById('watchAd');
      if (!btn) return;
      const local = readLocal();
      if ((window.__aether_pending && (window.__aether_pending.aeDelta || window.__aether_pending.adsDelta)) ||
          (current.lastAdTime && (Date.now() - (current.lastAdTime || 0) < 60000))) {
        btn.disabled = false;
        btn.innerText = `Watch Ad (+${100 * (current.multiplierAds || 1)} Ae)`;
        try { flushPending(false).catch(()=>{}); } catch(e){}
      }
    });

    // follow X button hook
    document.getElementById('followXBtn')?.addEventListener('click', ()=> {
      const X_URL = 'https://x.com/Aetherofficia97';
      try { window.open(X_URL, '_blank', 'noopener,noreferrer'); } catch(e) { location.href = X_URL; }
    });

    // periodic save small state + flush attempt
    setInterval(async ()=>{ try{ await saveSmallState(); await flushPending(false); }catch(e){} }, 60*1000);

  }catch(e){
    console.error('initApp err', e);
    if (tg.showAlert) tg.showAlert('Init error: ' + (e.message || e));
  }
}

/* ----------------- save small state ----------------- */
async function saveSmallState(){
  try{
    const small = { tonWallet: current.tonWallet||'', lastResetDate: current.lastResetDate||new Date().toDateString(), lastSaveTime: Date.now(), username: current.username||'' };
    await db.collection('users').doc(userDocId).set(small, { merge: true });
    writeLocal(current, window.__aether_pending);
  }catch(e){
    writeLocal(current, window.__aether_pending);
  }
}

/* ----------------- watchAd handler ----------------- */
async function watchAdHandler(){
  await resetDailyAdsIfNeeded();
  const now = Date.now();
  const local = readLocal();
  const s = local.state || {};
  const windowStart = s.adsWindowStart || current.adsWindowStart || now;
  let windowCount = s.adsWindowCount || current.adsWindowCount || 0;
  if (now - windowStart >= ADS_WINDOW_MS) { s.adsWindowStart = now; windowCount = 0; }

  if ((current.adsToday || 0) >= DAILY_AD_LIMIT) { if (tg.showAlert) tg.showAlert(`Daily limit reached (${DAILY_AD_LIMIT})`); return; }
  if (windowCount >= ADS_WINDOW_LIMIT) { if (tg.showAlert) tg.showAlert(`12h window limit reached (${ADS_WINDOW_LIMIT})`); return; }

  const btn = document.getElementById('watchAd');
  btn.disabled = true;
  const originalText = btn.innerText || `Watch Ad (+${100 * (current.multiplierAds || 1)} Ae)`;

  const prevAe = current.ae || 0;
  const prevTotalAds = current.totalAds || 0;

  try{
    const res = await showAdNormalized(30000);
    let completed = !!(res && res.completed);

    if (!completed){
      // small grace for external SDK callbacks
      await new Promise(r=>setTimeout(r, 1200));
      completed = (current.ae || 0) > prevAe || (current.totalAds || 0) > prevTotalAds;
    }

    if (!completed){
      // fallback short modal
      const fb = await showFallbackAdModal(18);
      if (!fb || !fb.completed) { if (tg.showAlert) tg.showAlert('Ad not completed.'); btn.disabled=false; btn.innerText = originalText; return; }
    }

    // success — credit locally + enqueue + try immediate write
    const reward = 100 * (current.multiplierAds || 1);
    current.ae = (current.ae || 0) + reward;
    current.totalAds = (current.totalAds || 0) + 1;
    current.adsToday = (current.adsToday || 0) + 1;
    current.lastAdTime = now;

    // update local window
    s.adsWindowStart = s.adsWindowStart || now;
    windowCount++;
    s.adsWindowCount = windowCount;
    current.adsWindowStart = s.adsWindowStart;
    current.adsWindowCount = s.adsWindowCount;

    enqueuePending(reward, 1, null, null);
    writeLocal(current, window.__aether_pending);

    // try immediate server update (best-effort)
    try{
      await db.collection('users').doc(userDocId).update({
        ae: firebase.firestore.FieldValue.increment(reward),
        totalAds: firebase.firestore.FieldValue.increment(1),
        adsToday: firebase.firestore.FieldValue.increment(1),
        lastAdTime: now,
        lastSaveTime: Date.now()
      });
      try{ await flushPending(false); } catch(e){}
    }catch(writeErr){
      console.warn('immediate write failed, pending queued', writeErr);
    }

    computeLevel(); updateUI(); updateAdReward();

    // cooldown random 10-30s
    const cooldown = 1000 * (10 + Math.floor(Math.random()*21));
    btn.innerText = `Cooldown ${Math.round(cooldown/1000)}s...`;
    setTimeout(()=>{ btn.disabled=false; btn.innerText = originalText; }, cooldown);

    if (tg.showAlert) tg.showAlert(`You get ${reward} Ae!`);
  }catch(err){
    console.warn('watchAdHandler err', err);
    if ((current.ae || 0) > prevAe || (current.totalAds || 0) > prevTotalAds){
      computeLevel(); updateUI(); updateAdReward();
      btn.disabled=false; btn.innerText = originalText;
      if (tg.showAlert) tg.showAlert(`You get ${(current.ae||0)-prevAe} Ae!`);
      return;
    }
    if (tg.showAlert) tg.showAlert('Ad failed. Try again later.');
    btn.disabled=false; btn.innerText = originalText;
  }
}

/* ----------------- referral handling ----------------- */
async function handleReferralParam(param){
  try{
    const referrerId = param.replace('ref_','');
    if (!referrerId || referrerId === userDocId) return;
    if (current.referredBy) return;
    const rDoc = await db.collection('users').doc(referrerId).get();
    if (!rDoc.exists) return;
    await db.collection('users').doc(referrerId).update({
      refs: firebase.firestore.FieldValue.arrayUnion(userDocId),
      ae: firebase.firestore.FieldValue.increment(5000)
    });
    current.referredBy = referrerId;
    current.ae = (current.ae||0) + 5000;
    enqueuePending(5000, 0, null, null);
    writeLocal(current, window.__aether_pending);
    await saveSmallState();
    if (tg.showAlert) tg.showAlert('Referral success! +5000 Ae!');
    loadRefList();
  }catch(e){ console.warn('handleReferral err', e); }
}
function copyRefHandler(){ const refLink = document.getElementById('myRef').innerText; navigator.clipboard.writeText(refLink).then(()=>tg.showAlert && tg.showAlert('Copied!')).catch(()=>tg.showAlert && tg.showAlert('Copy failed')); }

/* ----------------- airdrop toggle ----------------- */
function toggleAirdropSection(){ if ((current.refs||[]).length >= 3){ document.getElementById('airdrop-locked').style.display='none'; document.getElementById('airdrop-content').style.display='block'; } else { document.getElementById('airdrop-locked').style.display='block'; document.getElementById('airdrop-content').style.display='none'; } }

/* ----------------- wallet helpers ----------------- */
function updateWalletButtons(){ const connected = !!(current.tonWallet); document.getElementById('connectTon').style.display = connected ? 'none' : 'inline-block'; document.getElementById('disconnectTon').style.display = connected ? 'inline-block' : 'none'; document.getElementById('walletStatus').innerText = connected ? `Connected: ${current.tonWallet.slice(0,6)}...${current.tonWallet.slice(-4)}` : 'Not Connected'; }
async function trySaveTonWallet(addr){ current.tonWallet = addr; updateUI(); updateWalletButtons(); if (tg.showAlert) tg.showAlert('Wallet connected!'); enqueuePending(0,0,null,null); await saveSmallState(); }

/* ----------------- daily reset ----------------- */
async function resetDailyAdsIfNeeded(){ const today = new Date().toDateString(); if (current.lastResetDate !== today){ current.adsToday = 0; current.lastResetDate = today; await saveSmallState(); } }

/* ----------------- start app ----------------- */
initApp();

</script>
</body>
</html>
