<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>AETHER â€” 1.1 (Earn Â· Referral Â· TON)</title>

<!-- Telegram WebApp -->
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

<!-- TON Connect -->
<script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.css"/>

<!-- Ads -->
<script src='//libtl.com/sdk.js' data-zone='10192178' data-sdk='show_10192178'></script>

<style>
:root{ --bg:#000; --panel:#0b0d0f; --muted:#9aa0a6; --accent:#fff; --green:#00d38a }
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:Inter,Arial,sans-serif;background:linear-gradient(180deg,#000,#070707);color:var(--muted);padding:14px;min-height:100vh}
.wrap{max-width:720px;margin:12px auto}
.header{display:flex;gap:12px;align-items:center;padding:14px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border:1px solid rgba(255,255,255,0.03)}
.logo{width:64px;height:64px;border-radius:12px;background:linear-gradient(135deg,#111,#222);display:flex;align-items:center;justify-content:center;color:var(--accent);font-weight:900}
h1{color:var(--accent);font-size:18px;margin-bottom:2px}
.sub{color:var(--muted);font-size:13px}
.card{background:var(--panel);padding:14px;border-radius:12px;margin-top:12px;border:1px solid rgba(255,255,255,0.02)}
.stats{display:flex;gap:10px}
.stat{flex:1;padding:12px;background:rgba(255,255,255,0.02);border-radius:8px;text-align:center}
.v{font-weight:800;color:var(--accent);font-size:18px}
.tabs{display:flex;gap:8px;margin-top:12px}
.tab{flex:1;padding:10px;border-radius:10px;text-align:center;background:transparent;border:1px solid rgba(255,255,255,0.02);cursor:pointer;color:var(--muted)}
.tab.active{background:rgba(255,255,255,0.02);color:var(--accent)}
.section{display:none;padding-top:12px}
.section.active{display:block}
button.btn{width:100%;padding:12px;border-radius:12px;border:none;background:linear-gradient(90deg,#fff,#dfeaf6);color:#071018;font-weight:800;cursor:pointer}
button.ghost{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.03)}
.small{font-size:13px;color:var(--muted);margin-top:8px;text-align:center}
.ref-box{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:8px;background:rgba(255,255,255,0.01);word-break:break-word;overflow-wrap:break-word}
.levels{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:8px;margin-top:12px}
.level{padding:10px;border-radius:8px;background:rgba(255,255,255,0.01)}
.claimBtn{background:var(--green);color:#001;padding:8px;border-radius:8px;border:none;cursor:pointer;font-weight:700}
.footer{margin-top:18px;text-align:center;color:var(--muted);font-size:12px}
#loadingOverlay{position:fixed;top:0;left:0;width:100%;height:100%;background:var(--bg);display:flex;align-items:center;justify-content:center;z-index:9999;color:var(--accent);font-size:16px}
#loadingOverlay.hidden{display:none}
</style>
</head>
<body>
<div id="loadingOverlay">
  Loading Aether... <br><small>Please wait</small>
</div>

<div class="wrap" id="mainContent" style="display:none">
  <div class="header">
    <div class="logo">Ae</div>
    <div>
      <h1>AETHER â€” Earn & Airdrop</h1>
      <div id="userLine" class="sub">Loading...</div>
    </div>
  </div>

  <div class="card">
    <div class="stats">
      <div class="stat"><div class="v" id="points">0</div><div class="l">Coins</div></div>
      <div class="stat"><div class="v" id="refs">0</div><div class="l">Referrals</div></div>
      <div class="stat"><div class="v" id="level">1</div><div class="l">Level</div></div>
    </div>

    <div class="tabs">
      <div class="tab active" onclick="openTab('home')">Home</div>
      <div class="tab" onclick="openTab('tasks')">Tasks</div>
      <div class="tab" onclick="openTab('referral')">Referral</div>
      <div class="tab" onclick="openTab('airdrop')">Airdrop</div>
    </div>

    <!-- HOME -->
    <div id="home" class="section active">
      <div style="display:flex;gap:10px;align-items:center">
        <div style="flex:1">
          <button id="startMining" class="btn">Start Earning (Passive)</button>
          <p class="small">Daily login streak gives bonus. Claim level rewards in Tasks.</p>
        </div>
        <div style="width:88px;text-align:center">
          <div style="width:64px;height:64px;border-radius:12px;background:linear-gradient(135deg,#111,#222);display:flex;align-items:center;justify-content:center;color:var(--accent);font-weight:800">Ae</div>
        </div>
      </div>
    </div>

    <!-- TASKS -->
    <div id="tasks" class="section">
      <button id="watchAd" class="btn">Watch Rewarded Ad (+50)</button>
      <p class="small">Daily ads watched: <span id="adsToday">0</span> / <span id="adsLimit">20</span> | Total ads: <span id="totalAds">0</span></p>

      <div style="margin-top:12px" class="ref-box">
        <div>Join our channel (no coins):</div>
        <button id="openChannel" class="ghost">Open Channel</button>
      </div>

      <div class="small" style="margin-top:10px">Levels (claimable rewards):</div>
      <div id="levelsList" class="levels"></div>
      <div style="margin-top:10px;text-align:center"><button id="showAllLevels" class="ghost">Show More Levels</button></div>
    </div>

    <!-- REFERRAL -->
    <div id="referral" class="section">
      <div style="margin-bottom:8px">Invite friends â€” each successful referral = <strong>+500 coins</strong></div>
      <div class="ref-box">
        <div id="myRef" style="color:var(--accent);word-break:break-word;white-space:normal;overflow-wrap:break-word">Generating...</div>
        <div><button id="copyRef" class="ghost">COPY</button></div>
      </div>
      <p class="small" style="margin-top:8px">Only first-time joins via your link count. Unique ref code shown in header.</p>
    </div>

    <!-- AIRDROP -->
    <div id="airdrop" class="section">
      <div style="display:flex;gap:8px">
        <div style="flex:1"><button id="connectTon" class="btn">Connect TON Wallet</button></div>
        <div style="width:140px"><div id="tonBtnRoot"></div></div>
      </div>
      <div class="small" id="walletStatus">Not Connected</div>
      <div style="margin-top:12px"><button id="showBalance" class="ghost">Show Connected TON Address</button></div>
      <p class="small" style="margin-top:8px">Eligibility for airdrop: 10 referrals + 5000 coins. Airdrop date: Jan 1, 2026 â€” wallet changes blocked 7 days before airdrop.</p>
    </div>

  </div>
  <div class="footer">Â© Aether â€” Bot: @AetherMineXBot</div>
</div>

<script>
/* ========== CONFIG ========== */
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyBRMiyuGkjDFfZE9tqgzGVWJalw_6Cypz4",
  authDomain: "earncryptomp.firebaseapp.com",
  projectId: "earncryptomp",
  storageBucket: "earncryptomp.firebasestorage.app",
  messagingSenderId: "405204250643",
  appId: "1:405204250643:web:8841299bceb46f6752cfe6"
};
const AD_FN = 'show_10192178';
const DAILY_BASE = 20;
const ADS_COOLDOWN_MS = 5000;
const LEVELS_MAX = 1000;
const LEVEL_RENDER_CHUNK = 50; // Reduced for faster load
const TON_MANIFEST = 'https://karangangani.github.io/Earncrypto/tonconnect-manifest.json';
const AIRDROP_DATE = new Date('2026-01-01T00:00:00Z');
/* ============================ */

const loadingOverlay = document.getElementById('loadingOverlay');
const mainContent = document.getElementById('mainContent');

firebase.initializeApp(FIREBASE_CONFIG);
const db = firebase.firestore();
const auth = firebase.auth();

const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
if (tg) {
  tg.ready();
  tg.expand();
}
  const tgUser = (tg && tg.initDataUnsafe && tg.initDataUnsafe.user) || {};
let userDocId = null;
let current = {
  coins:0, refs:[], level:1, adsToday:0, totalAds:0, adsMilestones:[], claimedLevels:[], tonWallet:'', lastWalletChange:0, lastLogin:null, streak:0, joinedChannel:false, refCode:'', telegramId:''
};
let tonUI = null;
let adLastTime = 0;
let levelsRendered = 0;

const startParam = (tg && (tg.initDataUnsafe.start_param || tg.initDataUnsafe.startapp)) || new URLSearchParams(window.location.search).get('start') || new URLSearchParams(window.location.search).get('startapp') || '';

function userRef(){ return db.collection('users').doc(userDocId); }

async function initApp(){
  try {
    // FIXED: Auth first, then init
    await auth.signInAnonymously();
    const tgId = tgUser.id ? tgUser.id.toString() : 'fallback_' + Date.now();
    userDocId = tgId;
    
    let doc;
    try {
      doc = await Promise.race([userRef().get(), new Promise((_, r) => setTimeout(() => r(new Error('Timeout')), 5000))]);
    } catch (dbErr) {
      console.error('DB get fail:', dbErr);
      throw new Error('Connection timeout - try again');
    }
    
    if (!doc.exists) {
      current.refCode = tgId.slice(-8); // Shorter ref code
      current.telegramId = tgId;
      await userRef().set({
        telegramId: tgId,
        username: (tgUser.username || tgUser.first_name) || null,
        refCode: current.refCode,
        coins:0, refs:[], level:1, adsToday:0, totalAds:0, adsMilestones:[], claimedLevels:[], tonWallet:'', lastWalletChange:0, lastLogin:null, streak:0, joinedChannel:false
      }, { merge:true });
    } else {
      const data = doc.data();
      current = {
        coins: data.coins || 0,
        refs: data.refs || [],
        level: data.level || 1,
        adsToday: data.adsToday || 0,
        totalAds: data.totalAds || 0,
        adsMilestones: data.adsMilestones || [],
        claimedLevels: data.claimedLevels || [],
        tonWallet: data.tonWallet || '',
        lastWalletChange: data.lastWalletChange || 0,
        lastLogin: data.lastLogin || null,
        streak: data.streak || 0,
        joinedChannel: data.joinedChannel || false,
        refCode: data.refCode || tgId.slice(-8),
        telegramId: data.telegramId || tgId
      };
    }

    // FIXED: Realtime listener with proper error handling
    const unsubscribe = userRef().onSnapshot((d) => {
      if (!d.exists) return;
      const dd = d.data();
      current.coins = dd.coins || 0;
      current.refs = dd.refs || [];
      current.level = dd.level || 1;
      current.adsToday = dd.adsToday || 0;
      current.totalAds = dd.totalAds || 0;
      current.adsMilestones = dd.adsMilestones || [];
      current.claimedLevels = dd.claimedLevels || [];
      current.tonWallet = dd.tonWallet || '';
      current.lastWalletChange = dd.lastWalletChange || 0;
      current.joinedChannel = dd.joinedChannel || false;
      current.refCode = dd.refCode || current.refCode;
      updateUI();
      updateLevelProgressUI();
    }, (err) => {
      console.error('Snapshot error:', err);
      if (tg) tg.showAlert('Sync error - refresh app');
    });

    // FIXED: Ref link syntax error fixed (backticks instead of parens)
    try {
      const username = tgUser.username ? '@'+tgUser.username : (tgUser.first_name || 'Guest');
      document.getElementById('userLine').innerText = `\( {username} â€¢ \){current.refCode}`;
      const botUser = 'AetherMineXBot';
      const refLink = `https://t.me/\( {botUser}?startapp=ref_ \){current.refCode}`;
      document.getElementById('myRef').innerText = refLink;
      document.getElementById('copyRef').onclick = () => {
        navigator.clipboard.writeText(refLink).then(() => {
          if (tg) tg.showAlert('Link copied!');
        });
      };
    } catch (refErr) {
      console.error('Ref link fail:', refErr);
    }

    // FIXED: TON init with error handling
    try {
      if (window.TON_CONNECT_UI) {
        tonUI = new window.TON_CONNECT_UI.TonConnectUI({ 
          manifestUrl: TON_MANIFEST, 
          buttonRootId: 'tonBtnRoot' 
        });
        tonUI.onStatusChange(async (wallet) => {
          if (wallet && wallet.account) {
            const addr = wallet.account.address || wallet.account.walletAddress;
            await trySaveTonWallet(addr);
          } else {
            await userRef().update({ tonWallet: '', lastWalletChange: 0 }).catch(() => {});
            if (tg) tg.showAlert('Wallet disconnected');
          }
        });
      }
    } catch (tonErr) {
      console.error('TON init fail:', tonErr);
      document.getElementById('tonBtnRoot').innerHTML = '<div style="color:var(--muted);font-size:12px">TON not available</div>';
    }

    // Event handlers
    document.getElementById('connectTon').onclick = () => { 
      if (tonUI?.connectWallet) tonUI.connectWallet(); 
      else if (tg) tg.showAlert('TON wallet unavailable'); 
    };
    document.getElementById('watchAd').onclick = watchAdHandler;
    document.getElementById('openChannel').onclick = () => { 
      if (tg) tg.openTelegramLink('https://t.me/AetherMineX'); 
      else window.open('https://t.me/AetherMineX','_blank'); 
    };
    document.getElementById('startMining').onclick = startPassiveMining;
    document.getElementById('showAllLevels').onclick = () => renderLevelsChunk(LEVELS_MAX);
    document.getElementById('showBalance').onclick = () => { 
      if (!current.tonWallet) return (tg ? tg.showAlert('Connect TON first') : alert('Connect TON first')); 
      alert(`TON: ${current.tonWallet}`); 
    };
  await handleReferralParam();
    renderLevelsChunk(LEVEL_RENDER_CHUNK);
    await checkDailyLogin();

    updateUI();
    if (tg) tg.showAlert('Welcome to Aether! ðŸš€');

    // FIXED: Hide loading ONLY after success
    loadingOverlay.classList.add('hidden');
    mainContent.style.display = 'block';

    // Cleanup on close
    window.addEventListener('beforeunload', () => unsubscribe());

  } catch(e){ 
    console.error('initApp fail:', e); 
    if (tg) tg.showAlert('Init failed: ' + e.message); 
    loadingOverlay.innerHTML = `Error: ${e.message}<br><small>Retry /start</small>`;
  }
}

// Referral (unchanged but with better error handling)
async function handleReferralParam(){
  try {
    if (!startParam || !startParam.startsWith('ref_')) return;
    const refRaw = startParam.split('_')[1];
    if (!refRaw) return;
    const myTgId = tgUser.id ? tgUser.id.toString() : null;
    if (refRaw === myTgId) return;
    const meDoc = await userRef().get();
    const meData = meDoc.exists ? meDoc.data() : {};
    if (meData.referredBy) return;

    let refDoc = await db.collection('users').doc(refRaw).get();
    if (!refDoc.exists) {
      const snap = await db.collection('users').where('telegramId','==', refRaw).limit(1).get();
      if (!snap.empty) refDoc = snap.docs[0];
    }
    if (!refDoc.exists) {
      const snap = await db.collection('users').where('refCode','==', refRaw).limit(1).get();
      if (!snap.empty) refDoc = snap.docs[0];
    }
    if (!refDoc.exists) return;

    const refId = refDoc.id;
    await db.runTransaction(async (transaction) => {
      const refUserRef = db.collection('users').doc(refId);
      const refDocTrans = await transaction.get(refUserRef);
      if (!refDocTrans.exists) throw new Error('Referrer missing');
      const refData = refDocTrans.data();
      if (refData.refs && refData.refs.includes(myTgId)) throw new Error('Already referred');

      transaction.update(refUserRef, {
        refs: firebase.firestore.FieldValue.arrayUnion(myTgId),
        coins: firebase.firestore.FieldValue.increment(500)
      });
      transaction.set(userRef(), { referredBy: refId }, { merge: true });
      transaction.update(userRef(), { coins: firebase.firestore.FieldValue.increment(500) }); // Bonus for both
    });
    if (tg) tg.showAlert('Referral success! +500 coins each');
  } catch(e){ 
    console.error('Referral fail:', e); 
    if (tg) tg.showAlert('Referral error: ' + e.message); 
  }
}

// Other functions (optimized)
const BONUS = [100,200,300,400,500,700,1000];
async function checkDailyLogin(){
  try {
    const today = new Date().toDateString();
    const snap = await userRef().get();
    const data = snap.exists ? snap.data() : {};
    if (data.lastLogin !== today) {
      const streak = (data.streak || 0) % 7 + 1;
      const bonus = BONUS[streak-1] || 100;
      await userRef().update({
        coins: firebase.firestore.FieldValue.increment(bonus),
        streak: streak,
        lastLogin: today,
        adsToday: 0,
        adsMilestones: []
      });
      if (tg) tg.showAlert(`Daily streak bonus: +${bonus} coins!`);
    }
  } catch(e){ console.error('Login bonus fail:', e); }
}

function updateUI(){
  document.getElementById('points').innerText = Math.floor(current.coins || 0);
  document.getElementById('refs').innerText = (current.refs && current.refs.length) || 0;
  document.getElementById('level').innerText = current.level || 1;
  document.getElementById('adsToday').innerText = current.adsToday || 0;
  document.getElementById('totalAds').innerText = current.totalAds || 0;
  const dailyLimit = DAILY_BASE + (Math.max(0,(current.level||1)-1) * 20);
  document.getElementById('adsLimit').innerText = dailyLimit;
  if (current.tonWallet) {
    document.getElementById('walletStatus').innerText = `Connected: \( {current.tonWallet.slice(0,6)}... \){current.tonWallet.slice(-4)}`;
  } else {
    document.getElementById('walletStatus').innerText = 'Not Connected';
  }
}

function openTab(tab){
  document.querySelectorAll('.section').forEach(s=>s.classList.remove('active'));
  document.getElementById(tab).classList.add('active');
  document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
  document.querySelector(`[onclick="openTab('${tab}')"]`).classList.add('active');
}

let mining=false;
function startPassiveMining(){
  if (mining) {
    if (tg) tg.showAlert('Already mining! Check coins.');
    return;
  }
  mining=true;
  document.getElementById('startMining').innerText = 'Mining Active...';
  const interval = setInterval(async ()=>{
    if (!mining) {
      clearInterval(interval);
      return;
    }
    await userRef().update({ coins: firebase.firestore.FieldValue.increment(1) }).catch(()=>{});
  }, 2000); // Slower for realism
  if (tg) tg.showAlert('Passive mining started! +1 coin every 2s');
}

async function watchAdHandler(){
  try {
    const now = Date.now();
    const oneDay = 24*60*60*1000;
    const snap = await userRef().get();
    const data = snap.exists ? snap.data() : {};
    let adsTodayLocal = data.adsToday || 0;
    let lastAdTimeLocal = data.lastAdTime || 0;
    if (lastAdTimeLocal && now - lastAdTimeLocal > oneDay) {
      adsTodayLocal = 0;
    }
    const dailyLimit = DAILY_BASE + (Math.max(0,(current.level||1)-1) * 20);
    if (adsTodayLocal >= dailyLimit) return (tg?tg.showAlert('Daily limit reached'):alert('Daily limit reached'));
    if (now - adLastTime < ADS_COOLDOWN_MS) return (tg?tg.showAlert('Wait 5s'):alert('Wait 5s'));
    adLastTime = now;
    const btn = document.getElementById('watchAd');
    btn.disabled=true; btn.innerText='Loading Ad...';
    if (typeof window[AD_FN] === 'function'){
      try {
        await window[AD_FN]('pop');
        await grantAdReward(adsTodayLocal);
      } catch(e){
        console.error('Ad incomplete:', e);
        if (tg) tg.showAlert('Ad incomplete - no reward');
      }
    } else {
      await new Promise(r=>setTimeout(r,1500));
      await grantAdReward(adsTodayLocal);
    }
    btn.disabled=false; btn.innerText='Watch Rewarded Ad (+50)';
  } catch(e){ 
    console.error('Ad handler fail:', e); 
    if (tg) tg.showAlert('Ad error - try again');
  }
}

async function grantAdReward(adsTodayLocal){
  const totalAdsLocal = (current.totalAds || 0) + 1;
  const milestoneMap = {10:500,20:1000,50:3000};
  let bonus = 0;
  if (milestoneMap[totalAdsLocal] && !(current.adsMilestones || []).includes(totalAdsLocal)) bonus = milestoneMap[totalAdsLocal];
  await userRef().update({
    coins: firebase.firestore.FieldValue.increment(50 + bonus),
    adsToday: adsTodayLocal + 1,
    totalAds: totalAdsLocal,
    adsMilestones: firebase.firestore.FieldValue.arrayUnion(totalAdsLocal),
    lastAdTime: Date.now()
  });
  if (tg) tg.showAlert(`+50 coins\( {bonus ? ` + bonus \){bonus}` : ''}!`);
}

async function trySaveTonWallet(addr){
  try {
    const now = Date.now();
    const sevenDaysMs = 7*24*60*60*1000;
    if (AIRDROP_DATE - now <= sevenDaysMs){
      return (tg?tg.showAlert('Wallet lock: 7 days before airdrop'):alert('Wallet locked'));
    }
    const snap = await userRef().get();
    const data = snap.exists ? snap.data() : {};
    const lastChange = data.lastWalletChange || 0;
    const twelveHours = 12*60*60*1000;
    if (lastChange && (now - lastChange) < twelveHours){
      const remainingH = Math.ceil((twelveHours - (now - lastChange))/3600000);
      return (tg?tg.showAlert(`Wait \( {remainingH}h to change`):alert(`Wait \){remainingH}h`));
    }
    await userRef().update({ tonWallet: addr, lastWalletChange: now });
    if (tg) tg.showAlert(`Wallet ${addr.slice(0,6)}... connected!`);
  } catch(e){ 
    console.error('Wallet save fail:', e); 
    if (tg) tg.showAlert('Wallet save failed');
  }
}

function renderLevelsChunk(max){
  try {
    const container = document.getElementById('levelsList');
    const start = levelsRendered + 1;
    const end = Math.min(LEVELS_MAX, start + max - 1); // Chunk properly
    for (let i = start; i <= end; i++) {
      const refsNeeded = i;
      const adsNeeded = 10 + (i * 5);
      const reward = 500 * i;
      const el = document.createElement('div');
      el.className = 'level';
      el.innerHTML = `
        <div style="font-weight:800;color:var(--accent)">Level ${i}</div>
        <div class="small">Req: \( {refsNeeded} refs & \){adsNeeded} ads â€” Reward: ${reward} coins</div>
        <div style="margin-top:8px"><button id="claim_${i}" class="claimBtn" disabled>Claim</button></div>
      `;
      container.appendChild(el);
      document.getElementById(`claim_${i}`).onclick = () => claimLevel(i, refsNeeded, adsNeeded, reward);
    }
    levelsRendered = end;
    if (tg && end >= LEVELS_MAX) tg.showAlert('All levels loaded!');
    updateLevelProgressUI();
  } catch (levelErr) {
    console.error('Levels render fail:', levelErr);
    if (tg) tg.showAlert('Levels load error');
  }
}

async function updateLevelProgressUI(){
  try {
    const snap = await userRef().get();
    const data = snap.exists ? snap.data() : {};
    const refsCount = (data.refs && data.refs.length) || 0;
    const adsDone = data.totalAds || 0;
    for (let i=1; i<=levelsRendered; i++){
      const claimBtn = document.getElementById(`claim_${i}`);
      if (!claimBtn) continue;
      const refsNeeded = i;
      const adsNeeded = 10 + (i*5);
      const claimed = (data.claimedLevels || []).includes(i);
      const canClaim = !claimed && refsCount >= refsNeeded && adsDone >= adsNeeded;
      claimBtn.disabled = !canClaim;
      claimBtn.innerText = claimed ? 'Claimed' : 'Claim';
    }
    // Auto level up
    const potentialLevel = Math.min(refsCount, LEVELS_MAX);
    if (potentialLevel > current.level) {
      current.level = potentialLevel;
      await userRef().update({ level: potentialLevel });
    }
  } catch(e){ console.error('Level progress fail:', e); }
}

async function claimLevel(levelNo, refsNeeded, adsNeeded, reward){
  try {
    const snap = await userRef().get();
    const data = snap.exists ? snap.data() : {};
    const refsCount = (data.refs && data.refs.length) || 0;
    const adsDone = data.totalAds || 0;
    if (refsCount < refsNeeded || adsDone < adsNeeded){ 
      if (tg) tg.showAlert('Requirements not met'); 
      return; 
    }
    const claimed = data.claimedLevels || [];
    if (claimed.includes(levelNo)){ 
      if (tg) tg.showAlert('Already claimed'); 
      return; 
    }
    await userRef().update({
      coins: firebase.firestore.FieldValue.increment(reward),
      claimedLevels: firebase.firestore.FieldValue.arrayUnion(levelNo)
    });
    const newLevel = Math.min(refsCount, LEVELS_MAX);
    await userRef().update({ level: newLevel });
    current.level = newLevel;
    updateUI();
    if (tg) tg.showAlert(`Level \( {levelNo} claimed: + \){reward} coins! Now level ${newLevel}`);
  } catch(e){ 
    console.error('Claim fail:', e); 
    if (tg) tg.showAlert('Claim failed');
  }
}

// Start app
initApp();
setInterval(updateLevelProgressUI, 3000); // Less frequent for perf
</script>
</body>
</html>
