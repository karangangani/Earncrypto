<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>AETHER ‚Äî Earn & Airdrop (Updated)</title>

<!-- Telegram WebApp -->
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<!-- Firebase compat -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

<!-- TON connect UI -->
<script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.css"/>

<!-- Ad SDK -->
<script src='//libtl.com/sdk.js' data-zone='10192178' data-sdk='show_10192178'></script>

<style>
:root{ --bg:linear-gradient(135deg, #0c0c0c, #1a1a2e); --card:#0f0f23; --accent:#00d38a; --text:#fff; --muted:#a0a8b0; --border:rgba(0,211,138,0.3); --glow:0 0 20px rgba(0,211,138,0.5); }
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--bg); color: var(--muted); min-height: 100vh; padding: 14px; overflow-x: hidden; }
.wrap { max-width: 720px; margin: 12px auto; }
.header { display: flex; gap: 12px; align-items: center; padding: 14px; border-radius: 16px; background: linear-gradient(135deg, rgba(0,211,138,0.06), rgba(0,211,138,0.02)); border: 1px solid var(--border); box-shadow: var(--glow); }
.logo { width: 64px; height: 64px; border-radius: 16px; background: linear-gradient(135deg, #1a1a2e, #16213e); display: flex; align-items: center; justify-content: center; color: var(--text); font-weight: 900; position: relative; box-shadow: var(--glow); }
.logo::after { content: 'Ae'; font-size: 24px; font-weight: 900; color: var(--accent); text-shadow: var(--glow); }
.user-dp { width: 32px; height: 32px; border-radius: 50%; margin-left: 8px; border: 2px solid var(--accent); }
h1 { color: var(--text); font-size: 20px; margin-bottom: 2px; font-weight: 700; }
.sub { color: var(--muted); font-size: 13px; }
.card { background: var(--card); padding: 18px; border-radius: 16px; margin-top: 12px; border: 1px solid rgba(255,255,255,0.05); box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
.stats { display: flex; gap: 10px; }
.stat { flex: 1; padding: 14px; background: rgba(0,211,138,0.06); border-radius: 12px; text-align: center; transition: all 0.3s; }
.v { font-weight: 900; color: var(--text); font-size: 20px; }
.l { font-size: 11px; color: var(--muted); }
.tabs { display: flex; gap: 8px; margin-top: 12px; }
.tab { flex: 1; padding: 12px; border-radius: 12px; text-align: center; background: transparent; border: 1px solid rgba(255,255,255,0.05); cursor: pointer; color: var(--muted); transition: all 0.3s; font-weight: 600; }
.tab.active { background: rgba(0,211,138,0.2); color: var(--text); border-color: var(--accent); box-shadow: var(--glow); }
.section { display: none; padding-top: 12px; }
.section.active { display: block; animation: fadeIn 0.5s; }
.btn { width: 100%; padding: 14px; border-radius: 12px; border: none; background: linear-gradient(135deg, var(--accent), #00a877); color: #001; font-weight: 800; cursor: pointer; margin-top:8px; transition: all 0.3s; box-shadow: 0 4px 10px rgba(0,211,138,0.3); }
.btn.secondary { background: linear-gradient(135deg, #333, #555); color: #fff; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
.btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
.small { font-size: 13px; color: var(--muted); margin-top: 8px; text-align: center; }
.ref-box { display: flex; flex-direction: column; gap: 8px; padding: 12px; border-radius: 12px; background: rgba(0,211,138,0.04); border: 1px solid var(--border); }
.levels { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px; margin-top: 12px; }
.level { padding: 12px; border-radius: 12px; background: rgba(255,255,255,0.02); border: 1px solid var(--border); transition: all 0.3s; }
.claimBtn { background: linear-gradient(135deg, var(--accent), #00a877); color: #001; padding: 10px; border-radius: 8px; border: none; cursor: pointer; font-weight: 700; width: 100%; margin-top: 10px; transition: all 0.3s; }
.claimBtn:disabled { background: #333; color: #666; cursor:not-allowed; }
.leaderboard { list-style: none; padding: 0; }
.leader-item { padding: 10px; background: rgba(255,255,255,0.02); border-radius: 8px; margin-bottom: 8px; display: flex; justify-content: space-between; }
.ref-list { list-style: none; padding: 0; }
.ref-item { padding: 10px; background: rgba(255,255,255,0.02); border-radius: 8px; margin-bottom: 8px; }
.footer { margin-top: 20px; text-align: center; color: var(--muted); font-size: 12px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 12px; }
.welcome-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(26,26,46,0.95)); color: #fff; padding: 24px; border-radius: 16px; text-align: center; z-index: 1000; animation: popupFade 0.6s; border: 1px solid var(--border); box-shadow: var(--glow); display:none;}
@keyframes popupFade { from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); } to { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
#myRef { word-break: break-all; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 8px; color: var(--accent); }
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div class="logo"></div>
    <img id="user-dp" class="user-dp" src="" alt="User DP" style="display:none">
    <div>
      <h1>AETHER ‚Äî Earn & Airdrop</h1>
      <div id="userLine" class="sub">Loading...</div>
    </div>
  </div>

  <div class="card">
    <div class="stats">
      <div class="stat"><div class="v" id="points">0</div><div class="l">Ae</div></div>
      <div class="stat"><div class="v" id="refs">0</div><div class="l">Referrals</div></div>
      <div class="stat"><div class="v" id="level">0</div><div class="l">Level</div></div>
    </div>
      <div class="tabs">
      <div class="tab active" onclick="openTab('home', event)">Home</div>
      <div class="tab" onclick="openTab('tasks', event)">Earn</div>
      <div class="tab" onclick="openTab('referral', event)">Invite</div>
      <div class="tab" onclick="openTab('airdrop', event)">Airdrop</div>
    </div>

    <!-- HOME -->
    <div id="home" class="section active">
      <button id="startMining" class="btn">Start Passive Earning</button>
      <p class="small">+1 Ae every 2 seconds ‚Ä¢ Daily streak bonus (optional)</p>

      <div class="ref-box" style="margin-top:12px">
        <h3 style="color:var(--accent)">‚≠ê Official Channel</h3>
        <button id="openChannel" class="btn secondary">Join @Aetherofficialchannel</button>
      </div>
    </div>

    <!-- EARN -->
    <div id="tasks" class="section">
      <button id="watchAd" class="btn">Watch Ad (+<span id="adReward">100</span> Ae)</button>
      <p class="small" style="margin-top:8px">Level: <span id="levelDisplay">0</span> ‚Ä¢ Ads Watched: <span id="totalAds">0</span></p>

      <div class="small" style="margin-top:20px;font-weight:600;color:var(--accent)">Level Rewards</div>
      <div id="levelsList" class="levels"></div>
      <div style="text-align:center;margin-top:16px">
        <button id="showAllLevels" class="btn secondary">Load More Levels</button>
      </div>
    </div>

    <!-- INVITE -->
    <div id="referral" class="section">
      <div style="text-align:center;padding:20px">
        <h3 style="color:var(--accent);font-size:20px">Invite Friends & Earn</h3>
        <p style="margin-bottom:20px">Each referral = +5000 Ae for both!</p>
        <div class="ref-box">
          <div id="myRef">Generating...</div>
          <button id="copyRef" class="btn">COPY LINK</button>
        </div>
        <h3 style="color:var(--accent);font-size:20px;margin-top:20px">Your Referrals</h3>
        <ul id="refList" class="ref-list"></ul>
        <h3 style="color:var(--accent);font-size:20px;margin-top:20px">Leaderboard</h3>
        <div id="leaderList" class="leaderboard"></div>
      </div>
    </div>

    <!-- AIRDROP -->
    <div id="airdrop" class="section">
      <div id="airdrop-locked" style="display:none;text-align:center;padding:20px;color:#ff5555">
        <h3>Airdrop Locked</h3>
        <p>Invite 3 friends to unlock!</p>
      </div>
      <div id="airdrop-content" style="display:none;text-align:center;padding:20px">
        <h3 style="color:var(--accent);font-size:22px">Airdrop Ready</h3>
        <p>Connect your TON wallet to get Ae airdrop.</p>
        <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
          <button id="connectTon" class="btn">Connect TON Wallet</button>
          <button id="disconnectTon" class="btn secondary" style="display:none">Disconnect Wallet</button>
          <div id="tonBtnRoot"></div>
        </div>
        <p class="small" id="walletStatus" style="margin-top:16px">Not Connected</p>
      </div>
    </div>

  </div>

  <div class="footer">
    ¬© AETHER ‚Ä¢ Premium TON Project 2025
  </div>
</div>

<div id="welcome-popup" class="welcome-popup">
  <h2 style="color:var(--accent)">Welcome to Aether!</h2>
  <p>Earn Ae, invite friends & get ready for TON airdrop üöÄ</p>
  <button onclick="closeWelcome()" class="btn">Start Earning</button>
</div>

<div id="gift-popup" class="welcome-popup" style="display:none">
  <h2 style="color:var(--accent)">Level 10 Gift!</h2>
  <p>Congrats! Choose your reward:</p>
  <button id="gift2xAds" class="btn">2x Ae on Ads</button>
  <button id="gift2xAe" class="btn">2x All Ae</button>
</div>

<script>
/* ================== CONFIG ================== */
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyBRMiyuGkjDFfZE9tqgzGVWJalw_6Cypz4",
  authDomain: "earncryptomp.firebaseapp.com",
  projectId: "earncryptomp",
  storageBucket: "earncryptomp.firebasestorage.app",
  messagingSenderId: "405204250643",
  appId: "1:405204250643:web:8841299bceb46f6752cfe6"
};
const AD_FN = 'show_10192178';
const ADS_WINDOW_MS = 12 * 60 * 60 * 1000; // 12 hours
const ADS_WINDOW_LIMIT = 50;
const LOCAL_SYNC_MS = 24 * 60 * 60 * 1000; // 24 hours (batch flush)
const PENDING_KEY = 'aether_pending_v2';
const STATE_KEY = 'aether_state_v2';
const FLUSH_THRESHOLD_AE = 5000; // if pending Ae >= this, flush early
const TON_MANIFEST = 'https://karangangani.github.io/Earncrypto/tonconnect-manifest.json';

firebase.initializeApp(FIREBASE_CONFIG);
const db = firebase.firestore();
const auth = firebase.auth();

const tg = window.Telegram.WebApp;
tg.ready();
try { tg.expand(); } catch(e) { /* ignore */ }

const tgUser = tg.initDataUnsafe?.user || {};
let userDocId = null;

let current = {
  ae: 0,
  refs: [],            // array of userIds this user referred
  referredBy: '',      // the ID of the user who referred this user (if any)
  level: 0,
  adsToday: 0,
  totalAds: 0,
  claimedLevels: [],
  tonWallet: '',
  lastAdTime: 0,
  lastResetDate: new Date().toDateString(),
  multiplierAds: 1,
  multiplierAe: 1,
  giftChosen: false,
  lastSaveTime: Date.now()
};

let tonUI = null;
let levelsRendered = 0;
let unsubscribeSnapshot = null;
const startParam = tg.initDataUnsafe?.start_param || '';

function userRef() { return db.collection('users').doc(userDocId); }

/* ================== Local storage helpers & pending queue ================== */
function loadLocalStateAll() {
  try {
    const rawState = localStorage.getItem(STATE_KEY);
    const rawPending = localStorage.getItem(PENDING_KEY);
    const state = rawState ? JSON.parse(rawState) : {};
    const pending = rawPending ? JSON.parse(rawPending) : { aeDelta:0, adsDelta:0, refs:[], claimed:[], lastFlush:0 };
    return { state, pending };
  } catch (e) {
    return { state: {}, pending: { aeDelta:0, adsDelta:0, refs:[], claimed:[], lastFlush:0 } };
  }
}
function saveLocalStateAll(stateObj, pendingObj) {
  try {
    if (stateObj && typeof stateObj === 'object') localStorage.setItem(STATE_KEY, JSON.stringify(stateObj));
    if (pendingObj && typeof pendingObj === 'object') localStorage.setItem(PENDING_KEY, JSON.stringify(pendingObj));
  } catch (e) { console.warn('local save failed', e); }
}
// Initialize pending and load any saved state into current on startup
(function initLocal() {
  const { state, pending } = loadLocalStateAll();
  if (state && Object.keys(state).length) {
    // merge allowed fields into current
    const keys = ['ae','refs','referredBy','level','adsToday','totalAds','claimedLevels','tonWallet','lastAdTime','lastResetDate','multiplierAds','multiplierAe','giftChosen','lastSaveTime','adsWindowStart','adsWindowCount'];
    keys.forEach(k => { if (state[k] !== undefined) current[k] = state[k]; });
  }
  window.__aether_pending = pending;
})();

function queuePendingChange(aeDelta=0, adsDelta=0, addRef=null, addClaim=null) {
  window.__aether_pending = window.__aether_pending || { aeDelta:0, adsDelta:0, refs:[], claimed:[], lastFlush:0 };
  window.__aether_pending.aeDelta += aeDelta;
  window.__aether_pending.adsDelta += adsDelta;
  if (addRef) window.__aether_pending.refs.push(addRef);
  if (addClaim) window.__aether_pending.claimed.push(addClaim);
  saveLocalStateAll(current, window.__aether_pending);
}

async function flushPendingToFirestoreIfNeeded(force=false) {
  try {
    window.__aether_pending = window.__aether_pending || { aeDelta:0, adsDelta:0, refs:[], claimed:[], lastFlush:0 };
    const now = Date.now();

    // Nothing to flush
    if (!force && window.__aether_pending.aeDelta === 0 && window.__aether_pending.adsDelta === 0 && window.__aether_pending.refs.length === 0 && window.__aether_pending.claimed.length === 0) return;

    // If not forced and not yet past LOCAL_SYNC_MS, skip
    if (!force && (now - (window.__aether_pending.lastFlush || 0) < LOCAL_SYNC_MS) && Math.abs(window.__aether_pending.aeDelta) < FLUSH_THRESHOLD_AE) return;

    const updates = {};
    if (window.__aether_pending.aeDelta !== 0) updates.ae = firebase.firestore.FieldValue.increment(window.__aether_pending.aeDelta);
    if (window.__aether_pending.adsDelta !== 0) updates.totalAds = firebase.firestore.FieldValue.increment(window.__aether_pending.adsDelta);
    if (window.__aether_pending.refs.length) updates.refs = firebase.firestore.FieldValue.arrayUnion(...window.__aether_pending.refs);
    if (window.__aether_pending.claimed.length) updates.claimedLevels = firebase.firestore.FieldValue.arrayUnion(...window.__aether_pending.claimed);
    updates.lastSaveTime = Date.now();

    // perform server update (merge)
    await userRef().update(updates);

    // reset pending and record flush time
    window.__aether_pending = { aeDelta:0, adsDelta:0, refs:[], claimed:[], lastFlush: now };
    saveLocalStateAll(current, window.__aether_pending);
  } catch (e) {
    console.warn('flushPending error', e);
    // keep pending to attempt later
  }
}
async function forceFlushPending() { await flushPendingToFirestoreIfNeeded(true); }
  /* flush on unload (best effort - saves to localStorage which persists) */
window.addEventListener('beforeunload', function () {
  try { saveLocalStateAll(current, window.__aether_pending || { aeDelta:0, adsDelta:0, refs:[], claimed:[], lastFlush:0 }); } catch(e){}
});

/* periodic attempt to flush pending (every 5 minutes) */
setInterval(() => { flushPendingToFirestoreIfNeeded(false).catch(()=>{}); }, 5 * 60 * 1000);

/* ================== AD HELPER (robust) ================== */
/**
 * showAdNormalized()
 * - supports Promise-style, callback-style, event-style SDKs
 * - returns { completed: boolean }
 */
function showAdNormalized() {
  return new Promise((resolve) => {
    const TIMEOUT_MS = 30000; // 30s
    let done = false;
    const finish = (ok) => {
      if (done) return;
      done = true;
      try { window.removeEventListener('libtl_ad_result', eventHandler); } catch(e){}
      clearTimeout(timer);
      resolve({ completed: !!ok });
    };

    const timer = setTimeout(() => {
      console.warn('Ad SDK timeout');
      finish(false);
    }, TIMEOUT_MS);

    // 1) Promise-style
    try {
      if (window.show_10192178 && typeof window.show_10192178 === 'function') {
        try {
          const maybe = window.show_10192178('');
          if (maybe && typeof maybe.then === 'function') {
            maybe.then((res) => {
              if (res && typeof res === 'object') {
                if ('completed' in res) return finish(!!res.completed);
                if ('success' in res) return finish(!!res.success);
                if ('result' in res) return finish(res.result === 'completed' || res.result === 'success');
              }
              // resolved without detail -> assume completed
              return finish(true);
            }).catch((err) => {
              console.warn('Ad promise rejected', err);
              finish(false);
            });
            return;
          }
        } catch (ex) {
          console.warn('show_10192178 threw', ex);
        }
      }
    } catch(e){ console.warn(e); }

    // 2) callback-style (example libtl)
    try {
      if (window.libtl && typeof window.libtl.show === 'function') {
        try {
          window.libtl.show({
            zone: '10192178',
            onComplete: function() { finish(true); },
            onClose: function(watchedFully) { finish(!!watchedFully); },
            onError: function() { finish(false); }
          });
          return;
        } catch(ex) {
          console.warn('libtl.show error', ex);
        }
      }
    } catch(e){ console.warn(e); }

    // 3) global event fallback
    const eventHandler = (ev) => {
      try {
        const ok = !!(ev.detail && (ev.detail.completed || ev.detail.success || ev.detail.result === 'completed'));
        finish(ok);
      } catch(e) { finish(false); }
    };
    window.addEventListener('libtl_ad_result', eventHandler);

    // 4) fallback to calling SDK (some SDKs use internal callbacks)
    try {
      if (window.show_10192178 && typeof window.show_10192178 === 'function') {
        try { window.show_10192178(''); } catch(e){}
      }
    } catch(e){}
  });
}

/* ------------------------- INIT APP (reduced reads) ------------------------- */
async function initApp() {
  try {
    await auth.signInAnonymously();

    // keep doc keyed by Telegram id as you used (you can change to auth.uid later)
    const tgId = tgUser?.id ? tgUser.id.toString() : 'guest_' + Date.now();
    userDocId = tgId;

    // single read (reduce continuous reads)
    try {
      const docSnap = await userRef().get();
      const isNewUser = !docSnap.exists;
      const username = tgUser?.username || tgUser?.first_name || 'User';
      if (isNewUser) {
        const payload = { ...current, username: username };
        // create initial doc (necessary)
        await userRef().set(payload);
        Object.assign(current, payload);
      } else {
        Object.assign(current, docSnap.data());
      }
    } catch(e) {
      console.warn('initial read failed', e);
    }

    computeLevel();

    if (tgUser?.photo_url) {
      const el = document.getElementById('user-dp');
      el.src = tgUser.photo_url;
      el.style.display = 'block';
    }

    const username = tgUser?.username || tgUser?.first_name || 'User';
    document.getElementById('userLine').innerText = `${username} ‚Ä¢ ID: ${userDocId}`;

    // UI handlers
    document.getElementById('copyRef').onclick = copyRefHandler;
    document.getElementById('openChannel').onclick = () => tg.openTelegramLink('https://t.me/Aetherofficialchannel');
    document.getElementById('startMining').onclick = startPassiveMining;
    document.getElementById('showAllLevels').onclick = () => renderLevelsChunk(100);
    document.getElementById('watchAd').onclick = watchAdHandler;

    const refLink = `https://t.me/AetherMineXBot?start=ref_${userDocId}`;
    document.getElementById('myRef').innerText = refLink;

    tonUI = new TON_CONNECT_UI.TonConnectUI({ manifestUrl: TON_MANIFEST, buttonRootId: 'tonBtnRoot' });
    tonUI.onStatusChange(async (wallet) => {
      if (wallet && wallet.account && wallet.account.address) {
        await trySaveTonWallet(wallet.account.address);
      } else {
        try { await userRef().update({ tonWallet: '' }); } catch(e){}
        current.tonWallet = '';
        updateUI();
        updateWalletButtons();
      }
    });
    document.getElementById('connectTon').onclick = () => tonUI.connectWallet();
    document.getElementById('disconnectTon').onclick = async () => {
      try { await tonUI.disconnect(); } catch(e){}
      try { await userRef().update({ tonWallet: '' }); } catch(e){}
      current.tonWallet = '';
      updateUI();
      updateWalletButtons();
      tg.showAlert('Wallet disconnected!');
    };

    if (startParam && startParam.startsWith('ref_')) {
      await handleReferralParam(startParam);
    }

    renderLevelsChunk(20);
    await resetDailyAdsIfNeeded();
    updateUI();
    updateAdReward();
    await loadLeaderboard();
    loadRefList();

    setTimeout(() => { document.getElementById('welcome-popup').style.display = 'block'; }, 500);
    document.getElementById('gift2xAds')?.addEventListener('click', () => chooseGift('ads'));
    document.getElementById('gift2xAe')?.addEventListener('click', () => chooseGift('ae'));

    // periodic small save (profile fields) and attempt flush pending
    setInterval(async () => {
      if (Date.now() - (current.lastSaveTime || 0) >= 60000) {
        await saveDataToDb();
      }
    }, 60000);

  } catch (e) {
    console.error(e);
    tg.showAlert('Init error: ' + (e.message || e));
  }
}

/* ------------------------- LEVEL LOGIC ------------------------- */
function computeLevel() {
  const refsCount = (current.refs || []).length;
  const adsCount = current.totalAds || 0;
  current.level = Math.min(refsCount, adsCount);
  if (!Number.isFinite(current.level) || current.level < 0) current.level = 0;
}

/* ------------------------- GIFTS ------------------------- */
function checkLevel10Gift() {
  if (current.level >= 10 && !current.giftChosen) {
    document.getElementById('gift-popup').style.display = 'block';
  }
}
async function chooseGift(type) {
  if (type === 'ads') current.multiplierAds = 2;
  else if (type === 'ae') { current.multiplierAe = 2; current.ae = (current.ae || 0) * 2; }
  current.giftChosen = true;
  document.getElementById('gift-popup').style.display = 'none';
  // small profile write only
  await saveDataToDb();
  tg.showAlert(`Gift chosen: 2x ${type === 'ads' ? 'ads Ae' : 'all Ae'}!`);
}

/* ------------------------- WALLET ------------------------- */
function updateWalletButtons() {
  const connected = !!(current.tonWallet);
  document.getElementById('connectTon').style.display = connected ? 'none' : 'inline-block';
  document.getElementById('disconnectTon').style.display = connected ? 'inline-block' : 'none';
  document.getElementById('walletStatus').innerText = connected
    ? `Connected: ${current.tonWallet.slice(0,6)}...${current.tonWallet.slice(-4)}`
    : 'Not Connected';
}
async function trySaveTonWallet(addr) {
  current.tonWallet = addr;
  updateUI();
  updateWalletButtons();
  tg.showAlert('Wallet connected!');
  // small profile write only
  await saveDataToDb();
  }
  /* ------------------------- DAILY ------------------------- */
async function resetDailyAdsIfNeeded() {
  const today = new Date().toDateString();
  if (current.lastResetDate !== today) {
    current.adsToday = 0;
    current.lastResetDate = today;
    await saveDataToDb();
  }
}

/* ------------------------- REFERRAL (keeps immediate server update for referrer) ------------------------- */
async function handleReferralParam(param) {
  try {
    const referrerId = param.replace('ref_', '');
    if (!referrerId || referrerId === userDocId) return;
    if (current.referredBy) return;

    const refDoc = await db.collection('users').doc(referrerId).get();
    if (!refDoc.exists) return;

    // update referrer immediately (server-side)
    await db.collection('users').doc(referrerId).update({
      refs: firebase.firestore.FieldValue.arrayUnion(userDocId),
      ae: firebase.firestore.FieldValue.increment(5000)
    });

    // give current user local bonus and queue pending for server later
    current.referredBy = referrerId;
    current.ae = (current.ae || 0) + 5000;
    queuePendingChange(5000, 0, null, null); // queue current user's ae change
    saveLocalStateAll(current, window.__aether_pending);

    tg.showAlert('Referral success! +5000 Ae!');
    await loadRefList();
    await loadLeaderboard();
  } catch (e) {
    console.error('ref param error', e);
  }
}
function copyRefHandler() {
  const refLink = document.getElementById('myRef').innerText;
  navigator.clipboard.writeText(refLink).then(() => tg.showAlert('Copied!')).catch(()=>tg.showAlert('Copy failed'));
}

/* ------------------------- UI ------------------------- */
function updateUI() {
  document.getElementById('points').innerText = Math.floor(current.ae || 0);
  document.getElementById('refs').innerText = (current.refs || []).length;
  document.getElementById('level').innerText = current.level || 0;
  document.getElementById('levelDisplay').innerText = current.level || 0;
  document.getElementById('totalAds').innerText = current.totalAds || 0;
  updateWalletButtons();
}
function updateAdReward() {
  const reward = 100 * (current.multiplierAds || 1);
  document.getElementById('adReward').innerText = reward;
}

/* ------------------------- TABS ------------------------- */
function openTab(tabId, ev) {
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  document.getElementById(tabId).classList.add('active');
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  if (ev && ev.currentTarget) ev.currentTarget.classList.add('active');
  if (tabId === 'referral') {
    loadRefList();
    loadLeaderboard();
  }
  if (tabId === 'airdrop') toggleAirdropSection();
}

/* ------------------------- PASSIVE MINING ------------------------- */
let mining = false;
function startPassiveMining() {
  if (mining) return tg.showAlert('Already mining!');
  mining = true;
  document.getElementById('startMining').innerText = 'Mining Active...';
  setInterval(async () => {
    if (!mining) return;
    current.ae = (current.ae || 0) + (1 * (current.multiplierAe || 1));
    updateUI();
    // small profile save only
    if (Date.now() - (current.lastSaveTime || 0) > 30000) await saveDataToDb();
  }, 2000);
  tg.showAlert('Passive mining started!');
}

/* ------------------------- WATCH AD (with local batching & 12h window & cooldown) ------------------------- */
async function watchAdHandler() {
  await resetDailyAdsIfNeeded();

  // Load window state from local saved state
  const localState = loadLocalStateAll().state || {};
  const now = Date.now();
  localState.adsWindowStart = localState.adsWindowStart || now;
  localState.adsWindowCount = localState.adsWindowCount || 0;

  // reset window if passed
  if (now - localState.adsWindowStart >= ADS_WINDOW_MS) {
    localState.adsWindowStart = now;
    localState.adsWindowCount = 0;
  }

  if (localState.adsWindowCount >= ADS_WINDOW_LIMIT) {
    return tg.showAlert(`Ad limit reached (${ADS_WINDOW_LIMIT} per 12 hours). Come back later.`);
  }

  const btn = document.getElementById('watchAd');
  btn.disabled = true;
  const originalText = btn.innerText;
  btn.innerText = 'Loading Ad...';

  try {
    const res = await showAdNormalized();
    if (!res || !res.completed) {
      tg.showAlert('Ad not completed.');
      // small short cooldown to avoid immediate retry spamming UX
      setTimeout(()=>{ btn.disabled = false; btn.innerText = originalText; }, 1500);
      return;
    }

    const reward = 100 * (current.multiplierAds || 1);

    // local updates immediately for UI
    current.ae = (current.ae || 0) + reward;
    current.totalAds = (current.totalAds || 0) + 1;
    current.adsToday = (current.adsToday || 0) + 1;
    current.lastAdTime = now;

    // local window state update and save
    localState.adsWindowCount = (localState.adsWindowCount || 0) + 1;
    // merge into current so state persists
    current.adsWindowStart = localState.adsWindowStart;
    current.adsWindowCount = localState.adsWindowCount;

    // queue pending to flush later (reduces writes)
    queuePendingChange(reward, 1, null, null);
    saveLocalStateAll(current, window.__aether_pending);

    computeLevel();
    updateUI();
    updateAdReward();

    // random cooldown 10-30s
    const cooldown = 1000 * (10 + Math.floor(Math.random() * 21)); // 10..30 sec
    btn.innerText = `Cooldown ${Math.round(cooldown/1000)}s...`;
    setTimeout(() => {
      btn.disabled = false;
      btn.innerText = originalText || ('Watch Ad (+' + (100 * (current.multiplierAds || 1)) + ' Ae)');
    }, cooldown);

    // flush early if pending Ae big or time passed (prevent large local-only accumulation)
    if (Math.abs(window.__aether_pending.aeDelta || 0) >= FLUSH_THRESHOLD_AE || (Date.now() - (window.__aether_pending.lastFlush || 0)) > LOCAL_SYNC_MS) {
      await flushPendingToFirestoreIfNeeded(true);
    }

    tg.showAlert(`+${reward} Ae!`);
    await randomGame();
  } catch (e) {
    console.warn('watchAdHandler error', e);
    tg.showAlert('Ad failed. Try again later.');
    btn.disabled = false;
    btn.innerText = originalText || ('Watch Ad (+' + (100 * (current.multiplierAds || 1)) + ' Ae)');
  }
}

/* ------------------------- randomGame for UX ------------------------- */
async function randomGame() {
  const durations = [30, 60];
  const randomDuration = durations[Math.floor(Math.random() * durations.length)] * 1000;
  tg.showAlert(`Play a quick game for ${randomDuration / 1000} seconds to continue!`);
  await new Promise(r => setTimeout(r, randomDuration));
  tg.showAlert('Game complete!');
}

/* ------------------------- LEVELS & CLAIM ------------------------- */
function renderLevelsChunk(max) {
  const container = document.getElementById('levelsList');
  const start = levelsRendered + 1;
  const end = levelsRendered + max;
  for (let i = start; i <= end; i++) {
    const refsNeeded = i;
    const adsNeeded = i;
    const reward = 500 * i;
    const el = document.createElement('div');
    el.className = 'level';
    el.innerHTML = `
      <div style="font-weight:800;color:var(--accent);font-size:16px">Level ${i}</div>
      <div class="small" style="margin-top:8px">Requires: ${refsNeeded} referral${refsNeeded>1?'s':''} & ${adsNeeded} ad${adsNeeded>1?'s':''}</div>
      <div class="small" style="margin-top:8px">Reward: ${reward} Ae</div>
      <div style="margin-top:10px"><button id="claim_${i}" class="claimBtn" disabled>Claim</button></div>
    `;
    container.appendChild(el);
    const btn = document.getElementById(`claim_${i}`);
    btn.addEventListener('click', async () => {
      await claimLevel(i, refsNeeded, adsNeeded, reward);
    });
  }
  levelsRendered = end;
  updateLevelProgressUI();
}

function updateLevelProgressUI() {
  const refsCount = (current.refs || []).length;
  const adsDone = current.totalAds || 0;
  for (let i = 1; i <= levelsRendered; i++) {
    const btn = document.getElementById(`claim_${i}`);
    if (!btn) continue;
    const claimed = (current.claimedLevels || []).includes(i);
    const canClaim = !claimed && refsCount >= i && adsDone >= i;
    btn.disabled = !canClaim;
    btn.innerText = claimed ? 'Claimed ‚úì' : 'Claim';
  }
}

async function claimLevel(levelNo, refsNeeded, adsNeeded, reward) {
  const refsCount = (current.refs || []).length;
  const adsDone = current.totalAds || 0;
  if (refsCount < refsNeeded || adsDone < adsNeeded) {
    return tg.showAlert('Requirements not met');
  }
  if ((current.claimedLevels || []).includes(levelNo)) {
    return tg.showAlert('Already claimed');
  }

  // local update + queue pending claimedLevels and ae reward
  current.ae = (current.ae || 0) + reward;
  current.claimedLevels = current.claimedLevels || [];
  current.claimedLevels.push(levelNo);
  queuePendingChange(reward, 0, null, levelNo);
  saveLocalStateAll(current, window.__aether_pending);

  computeLevel();
  updateUI();
  updateLevelProgressUI();

  // try flush if threshold reached
  if (Math.abs(window.__aether_pending.aeDelta || 0) >= FLUSH_THRESHOLD_AE) {
    await flushPendingToFirestoreIfNeeded(true);
  }

  tg.showAlert(`Level ${levelNo} claimed! +${reward} Ae!`);
}

/* ------------------------- LEADERBOARD (top 100 with doc.id) ------------------------- */
async function loadLeaderboard() {
  try {
    const snapshot = await db.collection('users').orderBy('ae', 'desc').limit(100).get();
    const list = document.getElementById('leaderList');
    list.innerHTML = '';
    let rank = 1;
    snapshot.forEach(doc => {
      const data = doc.data();
      const item = document.createElement('div');
      item.className = 'leader-item';
      item.innerHTML = `<span>#${rank} ‚Ä¢ ${doc.id}</span><span>${Math.floor(data.ae || 0)} Ae</span>`;
      list.appendChild(item);
      rank++;
    });
  } catch (e) {
    console.error('leaderboard load error', e);
  }
}

/* ------------------------- REF LIST ------------------------- */
async function loadRefList() {
  const list = document.getElementById('refList');
  list.innerHTML = '';
  (current.refs || []).forEach(ref => {
    const item = document.createElement('li');
    item.className = 'ref-item';
    item.innerText = `User ID: ${ref}`;
    list.appendChild(item);
  });
}

/* ------------------------- AIRDROP ------------------------- */
function toggleAirdropSection() {
  if ((current.refs || []).length >= 3) {
    document.getElementById('airdrop-locked').style.display = 'none';
    document.getElementById('airdrop-content').style.display = 'block';
  } else {
    document.getElementById('airdrop-locked').style.display = 'block';
    document.getElementById('airdrop-content').style.display = 'none';
  }
}

/* ------------------------- saveDataToDb (reduced writes) ------------------------- */
async function saveDataToDb() {
  try {
    // write only small profile fields to reduce cost
    const smallPayload = {
      tonWallet: current.tonWallet || '',
      lastResetDate: current.lastResetDate || new Date().toDateString(),
      lastSaveTime: Date.now(),
      username: current.username || ''
    };
    await userRef().set(smallPayload, { merge: true });

    // persist local pending and state
    saveLocalStateAll(current, window.__aether_pending || { aeDelta:0, adsDelta:0, refs:[], claimed:[], lastFlush:0 });

    // attempt to flush pending if needed (may skip based on timing)
    await flushPendingToFirestoreIfNeeded(false);

    current.lastSaveTime = Date.now();
  } catch (e) {
    console.warn('saveDataToDb error', e);
  }
}

/* ------------------------- INITIALIZE ------------------------- */
initApp();

/* ------------------------- UTIL ------------------------- */
function closeWelcome() { document.getElementById('welcome-popup').style.display = 'none'; }

// helper to access local saved state (small wrapper)
function loadLocalStateAllPublic() { return loadLocalStateAll(); }
</script>
</body>
</html>
