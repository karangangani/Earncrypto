<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AetherMine — Wallet & Referral</title>

<!-- Telegram WebApp -->
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<!-- Firebase (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

<!-- WalletConnect v1 + QR (EVM wallets) -->
<script src="https://cdn.jsdelivr.net/npm/@walletconnect/client@1.6.6/dist/umd/index.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@walletconnect/qrcode-modal@1.6.0/dist/umd/index.min.js"></script>

<!-- ethers for chain reads + address validation -->
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>

<!-- LATEST TONCONNECT UI (FIXED MANIFEST) -->
<script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.css" />

<!-- Ad SDK (Rewarded Popup) -->
<script src='//libtl.com/sdk.js' data-zone='10192178' data-sdk='show_10192178'></script>

<style>
  :root{
    --bg:#050506; --panel:#0b0b0c; --muted:#9aa0a6; --accent:#eef6ff;
    --glass: rgba(255,255,255,0.02); --radius:14px;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#050606,#0a0a0b);color:var(--muted);padding:12px;min-height:100vh}
  .wrap{max-width:640px;margin:0 auto}
  .top{display:flex;gap:12px;align-items:center}
  .logoBox{width:64px;height:64px;border-radius:12px;background:linear-gradient(135deg,#111,#222);display:flex;align-items:center;justify-content:center;overflow:hidden}
  .logoBox img{width:100%;height:100%;object-fit:cover}
  .logoPlaceholder{font-weight:900;color:#e6eef8;font-size:20px}
  .title h1{font-size:18px;color:var(--accent);margin:0}
  .title p{font-size:13px;color:var(--muted);margin-top:4px}
  .card{background:var(--panel);border-radius:16px;padding:14px;margin-top:14px;border:1px solid rgba(255,255,255,0.03)}
  .stats{display:flex;gap:10px;justify-content:space-between}
  .stat{flex:1;padding:12px;background:var(--glass);border-radius:10px;text-align:center}
  .stat .v{font-weight:800;color:#fff;font-size:18px}
  .tabs{display:flex;gap:8px;margin-top:12px}
  .tab{flex:1;padding:10px;border-radius:12px;text-align:center;background:transparent;border:1px solid rgba(255,255,255,0.02);cursor:pointer;color:var(--muted)}
  .tab.active{background:linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));color:var(--accent)}
  .section{display:none;padding-top:12px}
  .section.active{display:block}
  .btn{display:inline-block;background:linear-gradient(90deg,#ffffff,#dfeaf6);color:#0a0a0a;border:none;padding:12px;border-radius:12px;font-weight:700;width:100%;cursor:pointer}
  .btn.ghost{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.03)}
  .small{font-size:13px;color:var(--muted);margin-top:8px;text-align:center}
  .ref-box{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;display:flex;gap:8px;align-items:center;justify-content:space-between;border:1px solid rgba(255,255,255,0.02);word-break:break-all}
  .ref-link{color:var(--accent);font-weight:700}
  .copy{background:#0b0c0d;color:var(--accent);border-radius:10px;padding:8px 10px;border:none;cursor:pointer}
  .levels{margin-top:12px;display:flex;flex-direction:column;gap:10px}
  .level{padding:12px;border-radius:10px;background:rgba(255,255,255,0.01);display:flex;justify-content:space-between;align-items:center;gap:10px}
  .level .meta{color:var(--muted);font-size:13px}
  .claimBtn{background:var(--accent);color:#071018;padding:8px 12px;border-radius:10px;border:none;cursor:pointer}
  .wallet-row{display:flex;gap:8px;margin-top:10px}
  .wallet-status{font-size:13px;color:var(--muted);margin-top:8px}
  .loader3d{width:56px;height:56px;border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#ffffff10,#ffffff05);animation:spin 4s linear infinite}
  @keyframes spin{0%{transform:rotateY(0) rotateX(0)}50%{transform:rotateY(180deg) rotateX(20deg)}100%{transform:rotateY(360deg) rotateX(0)}}
  footer{margin-top:18px;color:var(--muted);font-size:12px;text-align:center}
  #ton-connect { margin:10px 0; }
  .wallet-connected { color: #00ff88; font-weight: bold; }
  @media (max-width:420px){ .tabs{flex-direction:row} .stat .v{font-size:16px} }
</style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="logoBox" id="logoBox">
        <img id="logoImg" src="aether-icon.png" alt="Ae" onerror="document.getElementById('logoImg').style.display='none'; document.getElementById('logoPlaceholder').style.display='block'">
        <div id="logoPlaceholder" class="logoPlaceholder" style="display:none">Ae</div>
      </div>
      <div class="title">
        <h1>AETHER</h1>
        <p id="username">Loading...</p>
      </div>
    </div>

    <div class="card">
      <div class="stats">
        <div class="stat"><div class="v" id="points">0</div><div class="l">Points</div></div>
        <div class="stat"><div class="v" id="refs">0</div><div class="l">Referrals</div></div>
        <div class="stat"><div class="v" id="level">1</div><div class="l">Level</div></div>
      </div>

      <div class="tabs">
        <div class="tab active" onclick="openTab('home')">Home</div>
        <div class="tab" onclick="openTab('tasks')">Tasks</div>
        <div class="tab" onclick="openTab('referral')">Referral</div>
        <div class="tab" onclick="openTab('airdrop')">Airdrop</div>
      </div>

      <!-- HOME -->
      <div id="home" class="section active">
        <div style="margin-top:12px;display:flex;gap:12px;align-items:center">
          <div class="loader3d" title="Aether">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 2 L3 7 v10 l9 5 9-5V7z" stroke="#fff" stroke-width="0.8" fill="#fff1"/></svg>
          </div>
          <div style="flex:1">
            <button id="start-mining" class="btn">Start Earning (Passive)</button>
            <p class="small">Daily login bonus (7 day streak). Levels give claim rewards. Ads give points.</p>
          </div>
        </div>
      </div>

      <!-- TASKS -->
      <div id="tasks" class="section">
        <div style="margin-top:8px">
          <button id="watch-ad" class="btn">Watch Rewarded Ad (+50)</button>
          <p class="small">Daily ads watched: <span id="ads-today">0</span> / <span id="ads-limit">20</span></p>
          <div style="margin-top:8px" class="ref-box">
            <div style="font-size:13px;color:var(--muted)">Milestones example: 10→+500 | 20→+1000 | 50→+3000</div>
            <button id="join-channel" class="btn ghost" style="width:auto">Join Channel</button>
          </div>

          <div class="levels" id="levelsList"></div>
        </div>
      </div>

      <!-- REFERRAL -->
      <div id="referral" class="section">
        <div style="margin-top:12px">
          <p style="margin-bottom:8px">Invite friends — each successful referral = <strong>+500 pts</strong></p>
          <div class="ref-box">
            <div class="ref-link" id="ref-link">Generating...</div>
            <div><button class="copy" id="copy-ref">COPY</button></div>
          </div>
          <p class="small" style="margin-top:10px">Only first-time joins via your link count.</p>
        </div>
      </div>

      <!-- AIRDROP -->
      <div id="airdrop" class="section">
        <div style="margin-top:12px">
          <div style="display:flex;gap:8px">
            <button id="connect-wallet" class="btn">Connect Wallet (WalletConnect)</button>
            <button id="connect-ton" class="btn ghost">Connect TON Wallet</button>
            <button id="paste-wallet" class="btn ghost">Paste Wallet (Manual)</button>
          </div>
          <div id="wallet-status" class="wallet-status">Not Connected</div>
          <div class="small" id="chain-balance"></div>
          <div style="margin-top:10px"><button id="show-balance" class="btn ghost">Show Balance</button></div>
          <p class="small" style="margin-top:8px">Eligibility for airdrop: 10 referrals + 5000 points</p>
        </div>
      </div>

    </div>

    <footer>© AetherMine — Bot: @AetherMineXBot</footer>
  </div>

<script>
/* ========== CONFIG ========== */
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyBRMiyuGkjDFfZE9tqgzGVWJalw_6Cypz4",
  authDomain: "earncryptomp.firebaseapp.com",
  projectId: "earncryptomp",
  storageBucket: "earncryptomp.firebasestorage.app",
  messagingSenderId: "405204250643",
  appId: "1:405204250643:web:8841299bceb46f6752cfe6"
};
const BOT_TOKEN = "8359547898:AAGwkv22tGbWQZQChk8buqQnXXjC9i0ErDg"; // Your bot token for referral validation
const BOT_USERNAME = "AetherMineXBot";
const AD_SDK_FN = "show_10192178";           // must match your ad SDK global function
const ADS_COOLDOWN_MS = 5000;               // 5 seconds between ads
const DAILY_AD_LIMIT_BASE = 20;             // base daily ads (level gating increases)
const LEVELS_MAX = 100;                     // up to 100 levels
const TON_MANIFEST = 'https://raw.githubusercontent.com/ton-community/tutorials/main/03-client/test/public/tonconnect-manifest.json'; // Fixed manifest
/* =========================== */

/* Firebase init */
firebase.initializeApp(FIREBASE_CONFIG);
const db = firebase.firestore();
const auth = firebase.auth();

/* Telegram WebApp */
const tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
if (tg) tg.ready();
const tgUser = (tg && tg.initDataUnsafe && tg.initDataUnsafe.user) ? tg.initDataUnsafe.user : {};

/* TonConnect SDK (if present) */
const TonConnectSDK = window.TonConnect ? window.TonConnect : null;

/* WalletConnect (EVM) */
const WalletConnectGlobal = window.WalletConnect && (window.WalletConnect.default || window.WalletConnect);
const QRCodeModal = window.WalletConnectQRCodeModal && (window.WalletConnectQRCodeModal.default || window.WalletConnectQRCodeModal);

/* State */
let firebaseUid = null;
let wcConnector = null;
let current = {
  points:0, refs:[], level:1, adsToday:0, adsMilestones:[], wallet:"", tonWallet:"", lastLogin:null, streak:0, joinedChannel:false, claimedLevels:[], refCode: ''
};

/* Start param detection (supports ?start and ?startapp and tg.initDataUnsafe.start_param) */
const startParam = (tg && (tg.initDataUnsafe.start_param || tg.initDataUnsafe.startapp)) || new URLSearchParams(window.location.search).get('start') || new URLSearchParams(window.location.search).get('startapp') || '';

/* Auth (anonymous) */
auth.signInAnonymously().then(()=>{ firebaseUid = auth.currentUser.uid; initApp(); }).catch(e=>{ console.error("Auth failed",e); firebaseUid = "anon_"+Date.now(); initApp(); });

function userDocRef(){ return db.collection('users').doc(firebaseUid); }

/* Initialize app: create user doc if missing, setup referral link */
async function initApp(){
  try {
    const doc = await userDocRef().get();
    if (!doc.exists){
      const preferRef = (tg && tg.initDataUnsafe && tg.initDataUnsafe.user && tg.initDataUnsafe.user.id) ? tg.initDataUnsafe.user.id.toString() : null;
      const initialRefCode = preferRef || ('AM' + Math.random().toString(36).substr(2,6).toUpperCase());
      current.refCode = initialRefCode;
      await userDocRef().set({
        firebaseUid,
        telegramId: (tg && tg.initDataUnsafe && tg.initDataUnsafe.user && tg.initDataUnsafe.user.id) ? tg.initDataUnsafe.user.id.toString() : null,
        username: (tg && tg.initDataUnsafe && tg.initDataUnsafe.user && (tg.initDataUnsafe.user.username || tg.initDataUnsafe.user.first_name)) || null,
        refCode: initialRefCode,
        points:0, refs:[], level:1, adsToday:0, adsMilestones:[], wallet:"", tonWallet:"", lastLogin:null, streak:0, joinedChannel:false, referredBy:null, claimedLevels:[], createdAt: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge:true });
    } else {
      const data = doc.data();
      current.points = data.points || 0;
      current.refs = data.refs || [];
      current.level = data.level || 1;
      current.adsToday = data.adsToday || 0;
      current.adsMilestones = data.adsMilestones || [];
      current.wallet = data.wallet || "";
      current.tonWallet = data.tonWallet || "";
      current.lastLogin = data.lastLogin || null;
      current.streak = data.streak || 0;
      current.joinedChannel = data.joinedChannel || false;
      current.claimedLevels = data.claimedLevels || [];
      current.refCode = data.refCode || ('AM' + Math.random().toString(36).substr(2,6).toUpperCase());
      if (!data.refCode) await userDocRef().update({ refCode: current.refCode });
    }

    // set username if Telegram present
    document.getElementById('username').innerText = (tgUser && (tgUser.username || tgUser.first_name)) ? (tgUser.username ? "@" + tgUser.username : tgUser.first_name) : "Guest";

    // build referral link (prefer telegram id in link if available)
    const refIdForLink = (tgUser && tgUser.id) ? tgUser.id.toString() : firebaseUid;
    const myRefLink = `https://t.me/\( {BOT_USERNAME}?startapp=ref_ \){refIdForLink}`;
    document.getElementById('ref-link').innerText = myRefLink;
    document.getElementById('copy-ref').onclick = ()=> { navigator.clipboard.writeText(myRefLink); if (tg) tg.showAlert("Link copied"); else alert("Link copied"); };

    // render levels and UI
    renderLevels();
    await handleReferralParam();
    updateUI();
    checkDailyLogin();
  } catch (e){ console.error("initApp", e); if (tg) tg.showAlert("Init error"); }
}

/* Referral handling: apply referer reward once per referred user */
async function handleReferralParam(){
  try {
    if (!startParam || !startParam.startsWith('ref_')) return;
    const refId = startParam.split('_')[1]; if (!refId) return;

    const meDoc = await userDocRef().get();
    const meData = meDoc.exists ? meDoc.data() : {};
    if (meData.referredBy) return; // already referred

    // block self-referral
    if (refId === firebaseUid) return;
    if (tgUser && tgUser.id && refId === tgUser.id.toString()) return;

    // Try find referrer by doc id
    let refDocSnap = await db.collection('users').doc(refId).get();
    if (!refDocSnap.exists) {
      // fallback search by telegramId field
      const snap = await db.collection('users').where('telegramId','==', refId).limit(1).get();
      if (!snap.empty) refDocSnap = snap.docs[0];
      else return;
    }
  const refDocId = refDocSnap.id;
    // Update referrer points and refs array
    await db.collection('users').doc(refDocId).update({
      refs: firebase.firestore.FieldValue.arrayUnion(firebaseUid),
      points: firebase.firestore.FieldValue.increment(500)
    });
    // mark me as referred
    await userDocRef().set({ referredBy: refDocId }, { merge:true });

    // update local and UI
    current.refs.push(refDocId);
    updateUI();
    if (tg) tg.showAlert("Referral applied. Referrer +500 pts"); else alert("Referral applied. Referrer +500 pts");
  } catch (e) { console.error("handleReferralParam", e); }
}

/* Daily login bonus (7-day streak) */
const BONUS = [100,200,300,400,500,700,1000];
async function checkDailyLogin(){
  try {
    const today = new Date().toDateString();
    if (current.lastLogin !== today) {
      const streak = (current.streak % 7) + 1;
      const bonus = BONUS[streak-1] || 100;
      current.points = (current.points || 0) + bonus;
      current.streak = streak;
      current.lastLogin = today;
      current.adsToday = 0;
      current.adsMilestones = [];
      await userDocRef().update({ points: current.points, streak: current.streak, lastLogin: today, adsToday:0, adsMilestones: [] });
      if (tg) tg.showAlert(`Day \( {streak} Bonus: + \){bonus} pts`);
    }
    updateUI();
  } catch (e) { console.error("daily err", e); }
}

/* Update the UI */
function updateUI(){
  document.getElementById('points').innerText = Math.floor(current.points || 0);
  document.getElementById('refs').innerText = (current.refs && current.refs.length) || 0;
  document.getElementById('level').innerText = current.level || 1;
  document.getElementById('ads-today').innerText = current.adsToday || 0;
  document.getElementById('ads-limit').innerText = DAILY_BASE;
  document.getElementById('userLine').innerText = (tgUser.username ? '@'+tgUser.username : (tgUser.first_name || 'Guest')) + ' • ' + (current.refCode || '');
  if (current.wallet) document.getElementById('wallet-status').innerText = `\( {current.wallet.slice(0,6)}... \){current.wallet.slice(-4)}`;
  if (current.tonWallet) document.getElementById('wallet-status').innerText = 'TON: ' + current.tonWallet.slice(0,6) + '...' + current.tonWallet.slice(-4);
}

/* Tabs */
function openTab(tab){
  document.querySelectorAll('.section').forEach(s=>s.classList.remove('active'));
  document.getElementById(tab).classList.add('active');
  document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
  document.querySelector(`[onclick="openTab('${tab}')"]`).classList.add('active');
}

/* Render levels (display first 100 but UI shows first 20 for performance; claim logic supports any up to LEVELS_MAX) */
function renderLevels(){
  const container = document.getElementById('levelsList');
  container.innerHTML = '';
  for (let i=1;i<=Math.min(LEVELS_MAX,100);i++){
    const refsNeeded = i;                       // example progression: level N requires N refs
    const adsNeeded = 10 + (i*5);               // ads requirement growth
    const reward = i * 1000;                    // reward progression
    const div = document.createElement('div');
    div.className = 'level';
    div.innerHTML = `
      <div>
        <div style="font-weight:700;color:#fff">Level ${i}</div>
        <div class="meta">Requires: \( {refsNeeded} refs & \){adsNeeded} ads — Reward ${reward} pts</div>
      </div>
      <div style="text-align:right">
        <div id="lvlprogress_\( {i}" style="font-size:13px;color:var(--muted);margin-bottom:6px">Progress: 0/ \){refsNeeded} refs, 0/${adsNeeded} ads</div>
        <button class="claimBtn" id="claim_\( {i}" data-level=" \){i}">Claim</button>
      </div>
    `;
    container.appendChild(div);
    document.getElementById(`claim_${i}`).onclick = ()=> claimLevel(i, refsNeeded, adsNeeded, reward);
    // disable initially; updateLevelProgress will enable when ready
    document.getElementById(`claim_${i}`).disabled = true;
    if (i >= 20) { div.style.display = 'none'; } // show first 20 only — user can scroll later to others if need
  }
  setInterval(updateLevelProgress, 2000);
}

/* Update level progress for first 100 levels */
async function updateLevelProgress(){
  try {
    const doc = await userDocRef().get();
    const data = doc.exists ? doc.data() : {};
    const refsCount = (data.refs && data.refs.length) || 0;
    const adsDone = data.adsToday || 0;
    const claimed = data.claimedLevels || [];
    for (let i=1;i<=Math.min(LEVELS_MAX,100);i++){
      const refsNeeded = i;
      const adsNeeded = 10 + (i*5);
      const progressEl = document.getElementById(`lvlprogress_${i}`);
      const claimBtn = document.getElementById(`claim_${i}`);
      if (progressEl) progressEl.innerText = `Progress: \( {Math.min(refsCount, refsNeeded)}/ \){refsNeeded} refs, \( {Math.min(adsDone, adsNeeded)}/ \){adsNeeded} ads`;
      if (claimBtn){
        const isClaimed = (claimed || []).includes(i);
        claimBtn.disabled = isClaimed || !(refsCount >= refsNeeded && adsDone >= adsNeeded);
        claimBtn.innerText = isClaimed ? 'Claimed' : 'Claim';
      }
    }
  } catch (e) { console.error("updateLevelProgress err", e); }
}

/* Claim level reward */
async function claimLevel(levelNo, refsNeeded, adsNeeded, reward){
  try {
    const doc = await userDocRef().get();
    const data = doc.exists ? doc.data() : {};
    const refsCount = (data.refs && data.refs.length) || 0;
    const adsDone = data.adsToday || 0;
    if (refsCount < refsNeeded || adsDone < adsNeeded) { if (tg) tg.showAlert("Requirements not met"); else alert("Requirements not met"); return; }
    const claimed = data.claimedLevels || [];
    if (claimed.includes(levelNo)) { if (tg) tg.showAlert("Already claimed"); else alert("Already claimed"); return; }
    await userDocRef().update({
      points: firebase.firestore.FieldValue.increment(reward),
      claimedLevels: firebase.firestore.FieldValue.arrayUnion(levelNo)
    });
    current.points += reward;
    updateUI();
    if (tg) tg.showAlert(`Level \( {levelNo} claimed: + \){reward} pts`); else alert(`Level \( {levelNo} claimed: + \){reward} pts`);
    updateLevelProgress();
  } catch (e) { console.error("claimLevel err", e); if (tg) tg.showAlert("Claim failed"); else alert("Claim failed"); }
}

/* Ads logic: cooldown + daily gating + level gating */
let lastAdTime = 0;
document.getElementById('watch-ad').onclick = async ()=>{
  try {
    // compute daily limit by level
    const dailyLimit = Math.min(100, DAILY_AD_LIMIT_BASE + ((current.level - 1) * 20));
    if ((current.adsToday || 0) >= dailyLimit) return (tg ? tg.showAlert("Daily ad limit reached") : alert("Daily ad limit reached"));
    const now = Date.now();
    if (now - lastAdTime < ADS_COOLDOWN_MS) return (tg ? tg.showAlert("Please wait a few seconds between ads") : alert("Please wait"));
    lastAdTime = now;
    const btn = document.getElementById('watch-ad'); btn.disabled = true; btn.innerText = "Loading Ad...";
    if (typeof window[AD_SDK_FN] === 'function') {
      try {
        await window[AD_SDK_FN]('pop'); // your ad SDK call as requested
        await grantAdReward();
      } catch (e) {
        console.error("ad error", e);
        if (tg) tg.showAlert("Ad not completed"); else alert("Ad not completed");
      }
    } else {
      // fallback simulation for testing
      await new Promise(r => setTimeout(r, 1200));
      await grantAdReward();
    }
    btn.disabled = false; btn.innerText = "Watch Rewarded Ad (+50)";
  } catch (e) { console.error("watch-ad err", e); }
};

async function grantAdReward(){
  current.points = (current.points || 0) + 50;
  current.adsToday = (current.adsToday || 0) + 1;
  // milestone bonuses
  const M = {10:500,20:1000,50:3000};
  if (M[current.adsToday] && !(current.adsMilestones || []).includes(current.adsToday)) {
    current.points += M[current.adsToday];
    current.adsMilestones = current.adsMilestones || [];
    current.adsMilestones.push(current.adsToday);
  }
  await userDocRef().update({ points: current.points, adsToday: current.adsToday, adsMilestones: current.adsMilestones });
  updateUI();
  if (tg) tg.showAlert("+50 pts awarded"); else alert("+50 pts awarded");
}

/* Join channel button (should always be active) */
document.getElementById('join-channel').onclick = async ()=>{
  if (tg) tg.openTelegramLink('https://t.me/AetherMineX');
  else window.open('https://t.me/AetherMineX','_blank');
  // give points after redirect (best-effort)
  setTimeout(async ()=> {
    if (!current.joinedChannel){
      current.points += 500; current.joinedChannel = true;
      await userDocRef().update({ points: current.points, joinedChannel:true });
      updateUI();
      if (tg) tg.showAlert("500 pts claimed"); else alert("500 pts claimed");
    }
  }, 3500);
};

/* Copy-ref button */
document.getElementById('copy-ref').onclick = ()=> {
  const txt = document.getElementById('ref-link').innerText;
  navigator.clipboard.writeText(txt);
  if (tg) tg.showAlert("Copied!"); else alert("Copied!");
};

/* Passive earning (start mining) */
let mining = false;
document.getElementById('start-mining').onclick = ()=>{
  if (mining) return;
  mining = true;
  setInterval(async ()=>{
    current.points = (current.points || 0) + 1; // 1 point/sec baseline
    await userDocRef().update({ points: current.points }).catch(()=>{});
    updateUI();
  }, 1000);
};

/* ---------- WalletConnect (EVM) ---------- */
function getWCConnector(){
  if (wcConnector && wcConnector.connected) return wcConnector;
  if (!WalletConnectGlobal) throw new Error("WalletConnect missing");
  wcConnector = new WalletConnectGlobal({ bridge: "https://bridge.walletconnect.org" });
  return wcConnector;
}

document.getElementById('connect-wallet').onclick = async ()=>{
  try {
    const connector = getWCConnector();
    if (connector.connected) {
      const wallet = connector.accounts[0];
      await saveWallet(wallet); showWallet(wallet);
      if (tg) tg.showAlert("Wallet already connected");
      return;
    }
    await connector.createSession();
    const uri = connector.uri;
    // open walletconnect.com redirect - mobile wallets detect installed app
    const redirect = `https://walletconnect.com/wc?uri=${encodeURIComponent(uri)}`;
    const popup = window.open(redirect, '_blank');
    if (!popup && QRCodeModal && typeof QRCodeModal.open === 'function') QRCodeModal.open(uri, ()=>{});
    connector.on("connect", async (err, payload)=>{
      if (err) { console.error(err); if (tg) tg.showAlert("Connection failed"); return; }
      try { QRCodeModal && QRCodeModal.close(); } catch(e){}
      const accounts = payload.params[0].accounts;
      const wallet = accounts[0];
      await saveWallet(wallet); showWallet(wallet); if (tg) tg.showAlert("Wallet connected");
    });
    connector.on("session_update", (err, payload)=>{ if (!err){ const accounts = payload.params[0].accounts; if (accounts && accounts[0]) { saveWallet(accounts[0]); showWallet(accounts[0]); } }});
    connector.on("disconnect", (err, payload)=>{ current.wallet=""; userDocRef().update({ wallet:"" }).catch(()=>{}); document.getElementById('wallet-status').innerText="Not Connected"; document.getElementById('chain-balance').innerText=""; wcConnector=null; });
  } catch (e) {
    console.error("connect-wallet err", e);
    if (tg) tg.showAlert("WalletConnect not available in this browser. Use 'Paste Wallet' or 'Connect TON'"); else alert("Wallet connect error");
  }
};

/* Manual paste wallet fallback (guarantees saved address) */
document.getElementById('paste-wallet').onclick = async ()=>{
  try {
    const pasted = prompt("Paste your wallet address (EVM) here:");
    if (!pasted) return;
    const addr = pasted.trim();
    if (!ethers.utils.isAddress(addr)) { alert("Invalid address"); return; }
    await saveWallet(addr); showWallet(addr);
    if (tg) tg.showAlert("Wallet saved");
  } catch (e) { console.error("paste-wallet err", e); if (tg) tg.showAlert("Error saving wallet"); }
};

async function saveWallet(addr){
  current.wallet = addr;
  try { await userDocRef().update({ wallet: addr }); } catch(e){ console.error("saveWallet err", e); }
}
function showWallet(addr){ document.getElementById('wallet-status').innerText = `\( {addr.slice(0,6)}... \){addr.slice(-4)}`; }

/* Show balance read (EVM) */
document.getElementById('show-balance').onclick = async ()=>{
  try {
    const addr = current.wallet;
    if (!addr) return (tg ? tg.showAlert("Connect wallet first") : alert("Connect wallet first"));
    if (ethers.utils.isAddress(addr)) {
      const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/eth");
      const native = await provider.getBalance(addr);
      const eth = ethers.utils.formatEther(native);
      document.getElementById('chain-balance').innerText = `Balance: ${eth} ETH (read via ankr)`;
    } else {
      document.getElementById('chain-balance').innerText = "";
    }
  } catch (e) { console.error("show-balance err", e); if (tg) tg.showAlert("Error reading balance"); else alert("Error reading balance"); }
};

/* ---------- TON connect (best-effort) ---------- */
document.getElementById('connect-ton').onclick = async ()=>{
  try {
    // If TonConnect SDK included it will open wallet chooser
    if (TonConnectSDK) {
      const ton = new TonConnectSDK.TonConnect();
      const connection = await ton.connect(); // will open Ton modal
      if (connection && connection.account) {
        const tonAddr = connection.account.address || connection.account;
        await saveTonWallet(tonAddr); document.getElementById('wallet-status').innerText = `TON: \( {tonAddr.slice(0,6)}... \){tonAddr.slice(-4)}`;
        if (tg) tg.showAlert("TON wallet connected");
      }
      return;
    }
    // When opened inside Telegram, Telegram will show "Connect TON wallet" if tb.json on same origin is available
    if (tg) {
      tg.showAlert("If TON option doesn't appear Telegram in-app browser might block deep links. Ensure tb.json is hosted and open the mini app from bot link.");
      window.open(window.location.href, '_blank');
    } else {
      alert("TON connect not available in this browser.");
    }
  } catch (e) {
    console.error("connect-ton err", e);
    if (tg) tg.showAlert("TON connect failed. Ensure tb.json is correct and open from the Bot in Telegram."); else alert("TON connect failed");
  }
};
async function saveTonWallet(addr){
  current.tonWallet = addr;
  try { await userDocRef().update({ tonWallet: addr }); } catch(e){ console.error("saveTon err", e); }
}

/* ========== Firestore security rules suggestion ========== 
Paste these into Firestore rules (Firestore → Rules):

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      // Only authenticated clients (we sign-in anonymously) can read/write user docs
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
  }
  Important: The code above in this file uses anonymous auth and writes to /users/{auth.uid}.
If you keep the "allow read, write if request.auth != null" rule (less strict) then anonymous clients can write to any user doc (not recommended).
Prefer the stricter rule shown so each client can only update their own user document.
*/

/* End of script */
</script>
</body>
</html>
