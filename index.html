<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AetherMine — Wallet & Referral</title>

<!-- Telegram WebApp -->
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<!-- Firebase (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

<!-- WalletConnect v1 (for EVM wallets) + QR -->
<script src="https://cdn.jsdelivr.net/npm/@walletconnect/client@1.6.6/dist/umd/index.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@walletconnect/qrcode-modal@1.6.0/dist/umd/index.min.js"></script>

<!-- ethers for chain reads -->
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>

<!-- (TonConnect) best-effort attempt via unpkg (optional) -->
<script src="https://unpkg.com/@tonconnect/sdk@0.9.2/dist/tonconnect.umd.min.js"></script>

<!-- Ad SDK (your required snippet) -->
<script src='//libtl.com/sdk.js' data-zone='10192178' data-sdk='show_10192178'></script>

<style>
  /* ----- BLACK & WHITE THEME ----- */
  :root{ --bg:#060607; --panel:#0d0f10; --muted:#9aa0a6; --accent:#cfe9ff; --white:#ffffff; --glass:rgba(255,255,255,0.02); --radius:14px; }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#050606,#0a0a0b);color:var(--muted);padding:12px;min-height:100vh}
  .wrap{max-width:640px;margin:0 auto}
  .header{display:flex;align-items:center;gap:12px;padding:14px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border:1px solid rgba(255,255,255,0.03)}
  .logoBox{width:64px;height:64px;border-radius:12px;background:linear-gradient(135deg,#111,#222);display:flex;align-items:center;justify-content:center;overflow:hidden}
  .logoBox img{width:100%;height:100%;object-fit:cover}
  .logoPlaceholder{font-weight:900;color:#e6eef8;font-size:20px}
  .title h1{font-size:18px;color:var(--accent);margin:0}
  .title p{font-size:13px;color:var(--muted);margin-top:4px}
  .card{background:var(--panel);border-radius:16px;padding:14px;margin-top:14px;border:1px solid rgba(255,255,255,0.03)}
  .stats{display:flex;gap:10px;justify-content:space-between}
  .stat{flex:1;padding:12px;background:var(--glass);border-radius:10px;text-align:center}
  .stat .v{font-weight:800;color:var(--white);font-size:18px}
  .tabs{display:flex;gap:8px;margin-top:12px}
  .tab{flex:1;padding:10px;border-radius:12px;text-align:center;background:transparent;border:1px solid rgba(255,255,255,0.02);cursor:pointer;color:var(--muted)}
  .tab.active{background:linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));color:var(--accent)}
  .section{display:none;padding-top:12px}
  .section.active{display:block}
  .btn{display:inline-block;background:linear-gradient(90deg,#ffffff,#dfeaf6);color:#0a0a0a;border:none;padding:12px;border-radius:12px;font-weight:700;width:100%;cursor:pointer}
  .btn.ghost{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.03)}
  .small{font-size:13px;color:var(--muted);margin-top:8px;text-align:center}
  .ref-box{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;display:flex;gap:8px;align-items:center;justify-content:space-between;border:1px solid rgba(255,255,255,0.02);word-break:break-all}
  .ref-link{color:var(--accent);font-weight:700}
  .copy{background:#0b0c0d;color:var(--accent);border-radius:10px;padding:8px 10px;border:none;cursor:pointer}
  .levels{margin-top:12px;display:flex;flex-direction:column;gap:10px}
  .level{padding:12px;border-radius:10px;background:rgba(255,255,255,0.01);display:flex;justify-content:space-between;align-items:center;gap:10px}
  .level .meta{color:var(--muted);font-size:13px}
  .claimBtn{background:var(--accent);color:#071018;padding:8px 12px;border-radius:10px;border:none;cursor:pointer}
  .wallet-row{display:flex;gap:8px;margin-top:10px}
  .wallet-status{font-size:13px;color:var(--muted);margin-top:8px}
  .loader3d{width:56px;height:56px;border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#ffffff10,#ffffff05);animation:spin 4s linear infinite}
  @keyframes spin{0%{transform:rotateY(0) rotateX(0)}50%{transform:rotateY(180deg) rotateX(20deg)}100%{transform:rotateY(360deg) rotateX(0)}}
  footer{margin-top:18px;color:var(--muted);font-size:12px;text-align:center}
  /* Responsive */
  @media (max-width:420px){ .tabs{flex-direction:row} .stat .v{font-size:16px} }
</style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="logoBox" id="logoBox">
        <!-- if aether-icon.png present it will be used; else placeholder -->
        <img id="logoImg" src="aether-icon.png" alt="Ae" onerror="document.getElementById('logoImg').style.display='none'; document.getElementById('logoPlaceholder').style.display='block'">
        <div id="logoPlaceholder" class="logoPlaceholder" style="display:none">Ae</div>
      </div>
      <div class="title">
        <h1>AETHER</h1>
        <p id="username">Loading...</p>
      </div>
    </div>

    <div class="card">
      <div class="stats">
        <div class="stat"><div class="v" id="points">0</div><div class="l">Points</div></div>
        <div class="stat"><div class="v" id="refs">0</div><div class="l">Referrals</div></div>
        <div class="stat"><div class="v" id="level">1</div><div class="l">Level</div></div>
      </div>

      <div class="tabs">
        <div class="tab active" onclick="openTab('home')">Home</div>
        <div class="tab" onclick="openTab('tasks')">Tasks</div>
        <div class="tab" onclick="openTab('referral')">Referral</div>
        <div class="tab" onclick="openTab('airdrop')">Airdrop</div>
      </div>

      <!-- HOME -->
      <div id="home" class="section active">
        <div style="margin-top:12px">
          <div style="display:flex;gap:8px;align-items:center">
            <div class="loader3d" title="Aether">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 2 L3 7 v10 l9 5 9-5V7z" stroke="#fff" stroke-width="0.8" fill="#fff1"/></svg>
            </div>
            <div style="flex:1">
              <button id="start-mining" class="btn">Start Earning (Passive)</button>
              <p class="small">Daily login bonus (7 day streak). Levels give claim rewards. Ads give points.</p>
            </div>
          </div>
        </div>
      </div>

      <!-- TASKS -->
      <div id="tasks" class="section">
        <div style="margin-top:8px">
          <button id="watch-ad" class="btn">Watch Rewarded Ad (+50)</button>
          <p class="small">Daily ads watched: <span id="ads-today">0</span> / <span id="ads-limit">20</span></p>
          <div style="margin-top:8px" class="ref-box">
            <div style="font-size:13px;color:var(--muted)">Milestones example: 10→+500 | 20→+1000 | 50→+3000</div>
            <button id="join-channel" class="btn ghost" style="width:auto">Join Channel</button>
          </div>

          <div class="levels" id="levelsList"></div>
        </div>
      </div>

      <!-- REFERRAL -->
      <div id="referral" class="section">
        <div style="margin-top:12px">
          <p style="margin-bottom:8px">Invite friends — each successful referral = <strong>+500 pts</strong></p>
          <div class="ref-box">
            <div class="ref-link" id="ref-link">Generating...</div>
            <div><button class="copy" id="copy-ref">COPY</button></div>
          </div>
          <p class="small" style="margin-top:10px">Only first-time joins via your link count.</p>
        </div>
      </div>

      <!-- AIRDROP -->
      <div id="airdrop" class="section">
        <div style="margin-top:12px">
          <div style="display:flex;gap:8px">
            <button id="connect-wallet" class="btn">Connect Wallet (WalletConnect)</button>
            <button id="connect-ton" class="btn ghost">Connect TON Wallet</button>
            <button id="paste-wallet" class="btn ghost">Paste Wallet (Manual)</button>
          </div>
          <div id="wallet-status" class="wallet-status">Not Connected</div>
          <div class="small" id="chain-balance"></div>
          <div style="margin-top:12px"><button id="show-balance" class="btn ghost">Show Balance</button></div>
          <p class="small" style="margin-top:8px">Eligibility for airdrop: 10 referrals + 5000 points</p>
        </div>
      </div>

    </div>

    <footer>© AetherMine — Bot: @AetherMineXBot</footer>
  </div>

<script>
/* ===========================
   CONFIG - change only if needed
   =========================== */
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyBRMiyuGkjDFfZE9tqgzGVWJalw_6Cypz4",
  authDomain: "earncryptomp.firebaseapp.com",
  projectId: "earncryptomp",
  storageBucket: "earncryptomp.firebasestorage.app",
  messagingSenderId: "405204250643",
  appId: "1:405204250643:web:8841299bceb46f6752cfe6"
};
const BOT_USERNAME = "AetherMineXBot";
const AD_SDK_FN = "show_10192178"; // your ad sdk function
const DAILY_AD_LIMIT_BASE = 20; // default daily ads allowed before level unlock
const ADS_COOLDOWN_MS = 5000; // 5 seconds cooldown between ads
const LEVELS_MAX = 100;
/* =========================== */

/* Firebase init */
firebase.initializeApp(FIREBASE_CONFIG);
const db = firebase.firestore();
const auth = firebase.auth();

/* Telegram */
const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
if (tg) tg.ready();

/* TonConnect (if available) */
const TonConnectSDK = window.TonConnect ? window.TonConnect : null;

/* WalletConnect (EVM) */
const WalletConnectGlobal = window.WalletConnect && (window.WalletConnect.default || window.WalletConnect);
const QRCodeModal = window.WalletConnectQRCodeModal && (window.WalletConnectQRCodeModal.default || window.WalletConnectQRCodeModal);

let wcConnector = null;
let firebaseUid = null;
let current = { points:0, refs:[], level:1, adsToday:0, adsMilestones:[], wallet:"", tonWallet:"", lastLogin:null, streak:0, joinedChannel:false, refCode:'' };

/* read start param (works with ?start= and ?startapp= and tg.initDataUnsafe) */
const startParam = (tg && (tg.initDataUnsafe.start_param || tg.initDataUnsafe.startapp)) || new URLSearchParams(window.location.search).get('start') || new URLSearchParams(window.location.search).get('startapp') || '';

/* Sign-in anonymously (Firestore rules should allow request.auth != null) */
auth.signInAnonymously().then(()=>{ firebaseUid = auth.currentUser.uid; initApp(); }).catch((e)=>{ console.error("Auth error",e); firebaseUid = "anon_"+Date.now(); initApp(); });

function userDocRef(){ return db.collection('users').doc(firebaseUid); }

async function initApp(){
  try {
    // create doc if missing
    const doc = await userDocRef().get();
    if (!doc.exists) {
      const preferRef = (tg && tg.initDataUnsafe && tg.initDataUnsafe.user && tg.initDataUnsafe.user.id) ? tg.initDataUnsafe.user.id.toString() : null;
      const initialRefCode = preferRef || ('AM' + Math.random().toString(36).substr(2,6).toUpperCase());
      current.refCode = initialRefCode;
      await userDocRef().set({
        firebaseUid,
        telegramId: (tg && tg.initDataUnsafe && tg.initDataUnsafe.user && tg.initDataUnsafe.user.id) ? tg.initDataUnsafe.user.id.toString() : null,
        username: (tg && tg.initDataUnsafe && tg.initDataUnsafe.user && (tg.initDataUnsafe.user.username || tg.initDataUnsafe.user.first_name)) || null,
        refCode: initialRefCode,
        points:0, refs:[], level:1, adsToday:0, adsMilestones:[], wallet:"", tonWallet:"", lastLogin:null, streak:0, joinedChannel:false, referredBy:null, createdAt: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge:true });
    } else {
      const data = doc.data();
      current = {
        points: data.points || 0,
        refs: data.refs || [],
        level: data.level || 1,
        adsToday: data.adsToday || 0,
        adsMilestones: data.adsMilestones || [],
        wallet: data.wallet || "",
        tonWallet: data.tonWallet || "",
        lastLogin: data.lastLogin || null,
        streak: data.streak || 0,
        joinedChannel: data.joinedChannel || false,
        refCode: data.refCode || ('AM' + Math.random().toString(36).substr(2,6).toUpperCase()),
        referredBy: data.referredBy || null
      };
    }
     // build referral link (
    // prefer using telegram id in link for better UX like BUGminer: ?startapp=ref_<telegramId>
    const refIdForLink = ((tg && tg.initDataUnsafe && tg.initDataUnsafe.user && tg.initDataUnsafe.user.id) ? tg.initDataUnsafe.user.id.toString() : firebaseUid);
    const myRefLink = `https://t.me/${BOT_USERNAME}?startapp=ref_${refIdForLink}`;
    document.getElementById('ref-link').innerText = myRefLink;
    document.getElementById('copy-ref').onclick = ()=>{ navigator.clipboard.writeText(myRefLink); if (tg) tg.showAlert("Link copied"); else alert("Link copied"); };

    // try to apply referral (if user opened via other's ref link)
    await handleReferralParam();

    // populate levels UI
    renderLevels();

    updateUI();
    checkDailyLogin();
  } catch (e) {
    console.error("initApp err", e);
    if (tg) tg.showAlert("Init error");
  }
}

/* Referral handling (supports refId = firebaseUid or telegramId) */
async function handleReferralParam(){
  try {
    if (!startParam || !startParam.startsWith('ref_')) return;
    const refId = startParam.split('_')[1]; if (!refId) return;
    const meDoc = await userDocRef().get(); const meData = meDoc.exists ? meDoc.data() : {};
    if (meData.referredBy) return; // already referred
    // block self-referral
    if (refId === firebaseUid) return;
    if (tg && tg.initDataUnsafe && tg.initDataUnsafe.user && refId === tg.initDataUnsafe.user.id.toString()) return;

    // try doc lookup
    let refDocSnap = await db.collection('users').doc(refId).get();
    if (!refDocSnap.exists) {
      // fallback: search by telegramId
      const snap = await db.collection('users').where('telegramId', '==', refId).limit(1).get();
      if (!snap.empty) refDocSnap = snap.docs[0];
      else return;
    }
    const refDocId = refDocSnap.id;

    // credit referrer and mark me as referred
    await db.collection('users').doc(refDocId).update({
      refs: firebase.firestore.FieldValue.arrayUnion(firebaseUid),
      points: firebase.firestore.FieldValue.increment(500)
    });
    await userDocRef().set({ referredBy: refDocId }, { merge:true });

    if (tg) tg.showAlert("Referral applied. Referrer +500 pts");
    else alert("Referral applied. Referrer +500 pts");
  } catch (e) { console.error("handleReferralParam", e); }
}

/* DAILY login bonus */
const BONUS = [100,200,300,400,500,700,1000];
async function checkDailyLogin(){
  try {
    const today = new Date().toDateString();
    if (current.lastLogin !== today) {
      const streak = (current.streak % 7) + 1;
      const bonus = BONUS[streak-1] || 100;
      current.points += bonus;
      current.streak = streak;
      current.lastLogin = today;
      current.adsToday = 0;
      current.adsMilestones = [];
      await userDocRef().update({ points: current.points, streak: current.streak, lastLogin: today, adsToday:0, adsMilestones: [] });
      if (tg) tg.showAlert(`Day ${streak} Bonus: +${bonus} pts`);
    }
    updateUI();
  } catch (e) { console.error("daily err", e); }
}

/* UI updates */
function updateUI(){
  document.getElementById('points').innerText = Math.floor(current.points || 0);
  document.getElementById('refs').innerText = (current.refs && current.refs.length) || 0;
  document.getElementById('level').innerText = current.level || 1;
  document.getElementById('ads-today').innerText = current.adsToday || 0;
  const limit = DAILY_AD_LIMIT_BASE + (((current.refs && current.refs.length) || 0) * 0); // you can adjust formula
  document.getElementById('ads-limit').innerText = limit;
  if (current.wallet) document.getElementById('wallet-status').innerText = `${current.wallet.slice(0,6)}...${current.wallet.slice(-4)}`;
  if (current.tonWallet) document.getElementById('wallet-status').innerText = `TON: ${current.tonWallet.slice(0,6)}...${current.tonWallet.slice(-4)}`;
}

/* Tabs */
function openTab(tab) {
  document.querySelectorAll('.section').forEach(s=>s.classList.remove('active'));
  document.getElementById(tab).classList.add('active');
  document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
  document.querySelector(`[onclick="openTab('${tab}')"]`).classList.add('active');
}

/* LEVELS UI generation (up to LEVELS_MAX) */
function renderLevels(){
  const container = document.getElementById('levelsList');
  container.innerHTML = '';
  for (let i=1;i<=Math.min(20, LEVELS_MAX);i++){ // display first 20 by default, you can expand to 100 if desired
    const refsNeeded = i; // example: level i requires i referrals
    const adsNeeded = 10 + (i*5); // example progression
    const reward = i*1000;
    const div = document.createElement('div');
    div.className = 'level';
    div.innerHTML = `
      <div>
        <div style="font-weight:700;color:var(--white)">Level ${i}</div>
        <div class="meta">Requires: ${refsNeeded} refs & ${adsNeeded} ads — Reward ${reward} pts</div>
      </div>
      <div>
        <div style="font-size:13px;margin-bottom:6px" id="lvlprogress_${i}">Progress: 0/${refsNeeded} refs, 0/${adsNeeded} ads</div>
        <button class="claimBtn" id="claim_${i}" data-level="${i}">Claim</button>
      </div>
    `;
    container.appendChild(div);
    document.getElementById(`claim_${i}`).onclick = ()=> claimLevel(i, refsNeeded, adsNeeded, reward);
    // initial disable
    document.getElementById(`claim_${i}`).disabled = true;
  }
  // update progress periodically
  setInterval(updateLevelProgress, 2000);
}

/* Update level progress */
async function updateLevelProgress(){
  // load latest data
  const doc = await userDocRef().get();
  const data = doc.exists ? doc.data() : {};
  const refsCount = (data.refs && data.refs.length) || 0;
  const adsDone = data.adsToday || 0;
  for (let i=1;i<=Math.min(20, LEVELS_MAX); i++){
    const refsNeeded = i;
    const adsNeeded = 10 + (i*5);
    const progressEl = document.getElementById(`lvlprogress_${i}`);
    const claimBtn = document.getElementById(`claim_${i}`);
    if (progressEl) progressEl.innerText = `Progress: ${Math.min(refsCount, refsNeeded)}/${refsNeeded} refs, ${Math.min(adsDone, adsNeeded)}/${adsNeeded} ads`;
    if (claimBtn){
      const claimed = (data.claimedLevels || []).includes(i);
      claimBtn.disabled = claimed || !(refsCount>=refsNeeded && adsDone>=adsNeeded);
      claimBtn.innerText = claimed ? 'Claimed' : 'Claim';
    }
  }
}

/* Claim level reward */
async function claimLevel(levelNo, refsNeeded, adsNeeded, reward){
  try {
    const doc = await userDocRef().get();
    const data = doc.exists ? doc.data() : {};
    const refsCount = (data.refs && data.refs.length) || 0;
    const adsDone = data.adsToday || 0;
    if (refsCount < refsNeeded || adsDone < adsNeeded){ if (tg) tg.showAlert("Requirements not met"); else alert("Requirements not met"); return; }
    const claimedLevels = data.claimedLevels || [];
    if (claimedLevels.includes(levelNo)){ if (tg) tg.showAlert("Already claimed"); else alert("Already claimed"); return; }
    // give reward and mark level claimed
    await userDocRef().update({
      points: firebase.firestore.FieldValue.increment(reward),
      claimedLevels: firebase.firestore.FieldValue.arrayUnion(levelNo)
    });
    current.points += reward;
    updateUI();
    if (tg) tg.showAlert(`Level ${levelNo} claimed: +${reward} pts`); else alert(`Level ${levelNo} claimed: +${reward} pts`);
    updateLevelProgress();
  } catch (e){ console.error("claim err", e); if (tg) tg.showAlert("Claim failed"); else alert("Claim failed"); }
}

/* Ads logic: 5s cooldown + daily limits and level gating */
let lastAdTime = 0;
document.getElementById('watch-ad').onclick = async ()=>{
  try {
    const limitBase = DAILY_AD_LIMIT_BASE;
    const extra = 0; // you can modify based on level/referrals
    const dailyLimit = limitBase + extra;
    if ((current.adsToday||0) >= dailyLimit) return (tg ? tg.showAlert("Daily ad limit reached") : alert("Daily ad limit reached"));
    const now = Date.now();
    if (now - lastAdTime < ADS_COOLDOWN_MS) return (tg ? tg.showAlert("Please wait a few seconds between ads") : alert("Please wait"));
    lastAdTime = now;
    const btn = document.getElementById('watch-ad'); btn.disabled = true; btn.innerText = "Loading Ad...";

    // run ad via your SDK
    if (typeof window[AD_SDK_FN] === 'function') {
      try {
        await window[AD_SDK_FN]('pop');
        await grantAdReward();
      } catch (e) {
        console.error("ad error", e);
        if (tg) tg.showAlert("Ad not completed"); else alert("Ad not completed");
      }
    } else {
      // fallback - simulate ad for testing
      await new Promise(r=>setTimeout(r,1200));
      await grantAdReward();
    }

    btn.disabled = false; btn.innerText = "Watch Rewarded Ad (+50)";
  } catch (e) { console.error(e); }
};

async function grantAdReward(){
  current.points += 50;
  current.adsToday = (current.adsToday || 0) + 1;
  // milestone bonuses
  const M = {10:500,20:1000,50:3000};
  if (M[current.adsToday] && !(current.adsMilestones || []).includes(current.adsToday)) {
    current.points += M[current.adsToday];
    current.adsMilestones = current.adsMilestones || [];
    current.adsMilestones.push(current.adsToday);
  }
  await userDocRef().update({ points: current.points, adsToday: current.adsToday, adsMilestones: current.adsMilestones });
  updateUI();
  if (tg) tg.showAlert("+50 pts awarded"); else alert("+50 pts awarded");
}

/* Join channel */
document.getElementById('join-channel').onclick = async ()=>{
  if (current.joinedChannel) return (tg ? tg.showAlert("Already claimed") : alert("Already claimed"));
  if (tg) tg.openTelegramLink('https://t.me/AetherMineX');
  else window.open('https://t.me/AetherMineX','_blank');
  setTimeout(async ()=>{
    current.points += 500; current.joinedChannel = true;
    await userDocRef().update({ points: current.points, joinedChannel:true });
    updateUI();
    if (tg) tg.showAlert("500 pts claimed"); else alert("500 pts claimed");
  },3500);
};

/* COPY referral */
document.getElementById('copy-ref').onclick = ()=>{ const txt = document.getElementById('ref-link').innerText; navigator.clipboard.writeText(txt); if (tg) tg.showAlert("Copied!"); else alert("Copied!"); };

/* START mining (simple passive loop) */
let mining = false;
document.getElementById('start-mining').onclick = ()=>{
  if (mining) return;
  mining = true;
  setInterval(async ()=>{
    current.points = (current.points || 0) + 1; // 1 point per second baseline
    await userDocRef().update({ points: current.points }).catch(()=>{});
    updateUI();
  }, 1000);
};

/* ---------- WalletConnect (EVM) ---------- */
function getWCConnector(){
  if (wcConnector && wcConnector.connected) return wcConnector;
  if (!WalletConnectGlobal) throw new Error("WalletConnect missing");
  wcConnector = new WalletConnectGlobal({ bridge: "https://bridge.walletconnect.org" });
  return wcConnector;
}

document.getElementById('connect-wallet').onclick = async ()=>{
  try {
    const connector = getWCConnector();
    if (connector.connected) {
      const wallet = connector.accounts[0];
      await saveWallet(wallet);
      showWallet(wallet);
      if (tg) tg.showAlert("Wallet already connected");
      return;
    }
    await connector.createSession();
    const uri = connector.uri;
    // open walletconnect redirect
    const redirect = `https://walletconnect.com/wc?uri=${encodeURIComponent(uri)}`;
    const popup = window.open(redirect,'_blank');
    if (!popup && QRCodeModal && typeof QRCodeModal.open === 'function') {
      QRCodeModal.open(uri, ()=>{});
    }
    // events
    connector.on("connect", async (err, payload)=>{
      if (err) { console.error(err); if (tg) tg.showAlert("Connection failed"); return; }
      try { QRCodeModal && QRCodeModal.close(); } catch(e){}
      const accounts = payload.params[0].accounts;
      const wallet = accounts[0];
      await saveWallet(wallet); showWallet(wallet); if (tg) tg.showAlert("Wallet connected");
    });
    connector.on("session_update",(err,payload)=>{ if (!err){ const accounts = payload.params[0].accounts; if (accounts && accounts[0]) { saveWallet(accounts[0]); showWallet(accounts[0]); } }});
    connector.on("disconnect",(err,payload)=>{ current.wallet=""; userDocRef().update({ wallet: "" }).catch(()=>{}); document.getElementById('wallet-status').innerText="Not Connected"; document.getElementById('chain-balance').innerText=""; wcConnector=null; });
  } catch (e) {
    console.error("connect error", e);
    if (tg) tg.showAlert("Cannot connect wallet in this browser. Try 'Paste Wallet'"); else alert("Wallet connect error");
  }
};

/* Manual paste wallet fallback */
document.getElementById('paste-wallet').onclick = async ()=>{
  try {
    const pasted = prompt("Paste your wallet address (EVM) here:");
    if (!pasted) return;
    const addr = pasted.trim();
    if (!ethers.utils.isAddress(addr)) { alert("Invalid address"); return; }
    await saveWallet(addr);
    showWallet(addr);
    if (tg) tg.showAlert("Wallet saved");
  } catch(e){ console.error("paste wallet err", e); if (tg) tg.showAlert("Error saving wallet"); }
};

async function saveWallet(addr){
  current.wallet = addr;
  try { await userDocRef().update({ wallet: addr }); } catch(e){ console.error("saveWallet",e); }
}
function showWallet(addr){ document.getElementById('wallet-status').innerText = `${addr.slice(0,6)}...${addr.slice(-4)}`; }

/* Show balances (reads using ethers - using public RPC provider; change if needed) */
document.getElementById('show-balance').onclick = async ()=>{
  try {
    const addr = current.wallet || current.tonWallet;
    if (!addr) return (tg ? tg.showAlert("Connect wallet first") : alert("Connect wallet first"));
    // For EVM address, read via public RPC (Ankr)
    if (ethers.utils.isAddress(addr)) {
      const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/eth");
      const native = await provider.getBalance(addr);
      const eth = ethers.utils.formatEther(native);
      document.getElementById('chain-balance').innerText = `Balance: ${eth} ETH (RPC: ankr)`;
    } else {
      document.getElementById('chain-balance').innerText = "";
    }
  } catch(e){ console.error("balance err", e); if (tg) tg.showAlert("Error reading balance"); else alert("Error reading balance"); }
};

/* ---------- TON connect attempt (best-effort) ---------- */
document.getElementById('connect-ton').onclick = async ()=>{
  try {
    // If Telegram's built-in wallet UI is present (because you uploaded tb.json), Telegram may show TON option natively.
    // As a fallback we try TonConnect SDK (if included).
    if (TonConnectSDK) {
      // create tonconnect client
      const tonConnect = new TonConnectSDK.TonConnect();
      const connection = await tonConnect.connect(); // opens TonSDK modal to choose wallet
      if (connection && connection.account) {
        const tonAddr = connection.account.address || connection.account;
        await saveTonWallet(tonAddr);
        document.getElementById('wallet-status').innerText = `TON: ${tonAddr.slice(0,6)}...${tonAddr.slice(-4)}`;
        if (tg) tg.showAlert("TON wallet connected");
      }
      return;
    }
    if (tg) {
      // open tg manifest link to trigger built-in wallet choice — Telegram should show TON wallet option because tb.json is served from same domain
      tg.showPopup({ message: "If TON option does not appear, ensure tb.json is accessible and open this mini app from the Bot in Telegram."});
      // open a new tab to same origin to let Telegram detect manifest (some in-app browsers handle differently)
      window.open(window.location.href,'_blank');
    } else {
      alert("TON connect not available in this browser.");
    }
  } catch (e) {
    console.error("TON connect err", e);
    if (tg) tg.showAlert("TON connect failed. Ensure tb.json is correct and open from Telegram Bot link."); else alert("TON connect failed");
  }
};

async function saveTonWallet(addr){
  current.tonWallet = addr;
  try { await userDocRef().update({ tonWallet: addr }); } catch(e){ console.error("saveTon", e); }
  }
  
/* ========== Firestore rules recommendation ========== 
  Use these rules in Firebase console (Firestore > Rules):

  rules_version = '2';
  service cloud.firestore {
    match /databases/{database}/documents {
      match /users/{userId} {
        allow read, write: if request.auth != null;
      }
    }
  }

  This allows only authenticated clients (we use anonymous auth) to read/write users doc.
================================================= */

/* End of script */
</script>
</body>
</html>

